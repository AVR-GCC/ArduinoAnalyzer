/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.2.0
 * Git version: dcef523
 * Options:   --no-safe-math --no-math64 --no-bitfields --no-consts --no-float --no-divs --max-array-dim 2 --max-array-len-per-dim 8 --max-block-depth 2 --max-block-size 2 --max-expr-complexity 2 --max-funcs 4 --max-struct-fields 2 --max-union-fields 2 --output /specific/a/home/cc/students/cs/alonelmaliah//Desktop/avrTest/WorkFolder/avrtest.c
 * Seed:      1978698663
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint8_t  f0;
};

union U1 {
   volatile struct S0  f0;
};

/* --- GLOBAL VARIABLES --- */
static volatile int32_t g_2[5] = {1L,1L,1L,1L,1L};
static int32_t g_3[4] = {0x8E6E8384L,0x8E6E8384L,0x8E6E8384L,0x8E6E8384L};
static int32_t g_6 = 0xB8BC588EL;
static int32_t g_18[3][2] = {{0L,0L},{0L,0L},{0L,0L}};
static int8_t g_39 = 0L;
static union U1 g_50 = {{0UL}};/* VOLATILE GLOBAL g_50 */
static struct S0 g_64 = {1UL};
static int16_t g_99[6][3] = {{0xB3FFL,0x321CL,0xB3FFL},{0xB3FFL,0x321CL,0xB3FFL},{0xB3FFL,0x321CL,0xB3FFL},{0xB3FFL,0x321CL,0xB3FFL},{0xB3FFL,0x321CL,0xB3FFL},{0xB3FFL,0x321CL,0xB3FFL}};
static struct S0 * volatile g_117 = (void*)0;/* VOLATILE GLOBAL g_117 */
static uint32_t g_132 = 18446744073709551612UL;
static int32_t g_133 = 0x1AB7CBE3L;
static struct S0 * volatile g_134 = &g_64;/* VOLATILE GLOBAL g_134 */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
static struct S0  func_19(int16_t  p_20, int32_t  p_21, int32_t * p_22, struct S0  p_23);
static struct S0  func_28(int32_t  p_29, uint8_t  p_30, int32_t * p_31);
static union U1 * func_41(int8_t * p_42, int8_t * p_43, int8_t * p_44, struct S0  p_45, union U1 * p_46);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_2 g_18 g_6 g_39 g_64 g_132 g_133 g_134 g_99
 * writes: g_3 g_6 g_18 g_39 g_2 g_99 g_64
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    int32_t l_9 = 0L;
    int32_t *l_17 = &g_18[1][0];
    for (g_3[2] = 0; (g_3[2] >= (-27)); g_3[2] -= 4)
    { /* block id: 3 */
        uint32_t l_24 = 18446744073709551615UL;
        struct S0 l_25 = {0x92L};
        for (g_6 = 0; (g_6 > (-23)); --g_6)
        { /* block id: 6 */
            uint32_t l_10 = 1UL;
            int32_t *l_11 = (void*)0;
            int32_t l_12 = 0xE1B1B552L;
            l_12 ^= (l_9 > l_10);
            if (g_2[2])
                continue;
        }
        for (g_6 = 0; (g_6 <= 21); g_6 += 8)
        { /* block id: 12 */
            g_18[1][0] ^= (((int8_t)((l_17 = (void*)0) != (void*)0) >> (int8_t)4) == l_9);
            (*g_134) = func_19(l_24, g_18[1][0], &g_18[2][1], l_25);
        }
    }
    return g_99[2][1];
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_3 g_6 g_18 g_39 g_64 g_132 g_133
 * writes: g_39 g_18 g_2 g_99
 */
static struct S0  func_19(int16_t  p_20, int32_t  p_21, int32_t * p_22, struct S0  p_23)
{ /* block id: 15 */
    uint8_t l_34 = 255UL;
    int32_t l_35 = 0x52A2C7A2L;
    int32_t *l_36 = &g_3[3];
    struct S0 l_118 = {246UL};
    for (p_23.f0 = 0; (p_23.f0 < 3); p_23.f0 += 2)
    { /* block id: 18 */
        int16_t *l_130 = &g_99[2][1];
        uint8_t l_131[8][2] = {{251UL,246UL},{246UL,251UL},{246UL,246UL},{251UL,246UL},{246UL,251UL},{246UL,246UL},{251UL,251UL},{251UL,0xCEL}};
        int i, j;
        l_118 = func_28(((uint16_t)(l_35 ^= (g_2[4] > l_34)) % (uint16_t)g_3[2]), g_6, l_36);
        (*p_22) = (+((uint16_t)((int16_t)((int16_t)(((((((uint16_t)(((((int16_t)((*l_130) = g_2[3]) * (int16_t)l_131[6][1]) && g_132) && p_20) >= p_20) % (uint16_t)p_23.f0) | l_131[6][1]) == 0xA7A8449DL) <= 0x031CL) > g_39) || (*p_22)) >> (int16_t)4) + (int16_t)g_133) << (uint16_t)3));
    }
    return p_23;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_18 g_39 g_64
 * writes: g_39 g_18 g_2
 */
static struct S0  func_28(int32_t  p_29, uint8_t  p_30, int32_t * p_31)
{ /* block id: 20 */
    int32_t l_37 = 0x57B6A69EL;
    int8_t *l_38 = &g_39;
    int32_t l_79 = 0x49DA01FEL;
    int32_t l_80 = 0L;
    int32_t l_81 = 0x4AAFB9A3L;
    int32_t l_82 = 0x5A62595BL;
    int32_t l_83 = (-5L);
    int32_t l_84 = 1L;
    int32_t l_85 = 0x49794E54L;
    int32_t l_86 = (-9L);
    int32_t l_87 = 0L;
    int32_t l_88 = (-1L);
    int32_t l_89 = 5L;
    int32_t l_90 = 2L;
    uint32_t l_91 = 6UL;
    int32_t *l_103 = &l_79;
    int32_t *l_104 = &g_18[1][0];
    int32_t *l_105 = &l_37;
    int32_t *l_106 = &l_89;
    int32_t *l_107 = &l_87;
    int32_t *l_108 = &g_18[1][1];
    int32_t *l_109 = &l_84;
    int32_t *l_110 = &l_81;
    int32_t *l_111 = (void*)0;
    int32_t *l_112 = &l_89;
    int32_t *l_113[5] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
    uint32_t l_114 = 4294967295UL;
    int i;
lbl_102:
    if ((((*l_38) = ((l_37 , l_37) && p_30)) > g_3[1]))
    { /* block id: 22 */
        int32_t *l_40 = &g_18[1][0];
        int8_t *l_47 = &g_39;
        struct S0 l_48 = {1UL};
        union U1 *l_49 = &g_50;
        union U1 **l_76 = &l_49;
        (*l_40) &= 0xEEA3821CL;
        (*l_76) = func_41(l_47, l_38, l_47, l_48, l_49);
    }
    else
    { /* block id: 38 */
        int32_t *l_77 = (void*)0;
        int32_t *l_78[3];
        struct S0 l_101[5][3] = {{{0x5EL},{1UL},{0x5EL}},{{0x67L},{0x2AL},{0x67L}},{{0x5EL},{1UL},{0x5EL}},{{0x67L},{0x2AL},{0x67L}},{{0x5EL},{1UL},{0x5EL}}};
        int i, j;
        for (i = 0; i < 3; i++)
            l_78[i] = &l_37;
        ++l_91;
        for (l_37 = 0; (l_37 < (-6)); l_37 -= 7)
        { /* block id: 42 */
            int16_t *l_98[4];
            int32_t l_100 = (-6L);
            int i;
            for (i = 0; i < 4; i++)
                l_98[i] = &g_99[2][1];
            g_2[3] = ((int16_t)(l_100 = 4L) >> (int16_t)4);
            if (p_30)
                goto lbl_102;
            return l_101[0][2];
        }
    }
    l_114++;
    return g_64;
}


/* ------------------------------------------ */
/* 
 * reads : g_39
 * writes: g_2
 */
static union U1 * func_41(int8_t * p_42, int8_t * p_43, int8_t * p_44, struct S0  p_45, union U1 * p_46)
{ /* block id: 24 */
    union U1 **l_51 = (void*)0;
    union U1 *l_53 = &g_50;
    union U1 **l_52 = &l_53;
    int32_t l_69[7][2] = {{0x45A15B62L,0x429123EBL},{0x429123EBL,0x45A15B62L},{0x429123EBL,0x429123EBL},{0x45A15B62L,0x429123EBL},{0x429123EBL,0x45A15B62L},{0x429123EBL,0x429123EBL},{0x45A15B62L,0x429123EBL}};
    int i, j;
    (*l_52) = &g_50;
    if (((int16_t)((uint8_t)((int16_t)0xADFEL - (int16_t)(-1L)) * (uint8_t)0xEDL) + (int16_t)g_39))
    { /* block id: 26 */
        struct S0 *l_63 = &g_64;
        int32_t *l_65 = (void*)0;
        int32_t *l_66 = &g_18[0][1];
        int32_t *l_67 = &g_18[1][0];
        int32_t *l_68[1][4] = {{(void*)0,(void*)0,(void*)0,(void*)0}};
        uint16_t l_70[3][8] = {{0UL,9UL,9UL,0UL,0x943CL,0UL,9UL,9UL},{9UL,0x943CL,0xE484L,0xE484L,0x943CL,9UL,0x943CL,0xE484L},{0UL,0x943CL,0UL,9UL,9UL,0UL,0x943CL,0UL}};
        int i, j;
        for (p_45.f0 = 26; (p_45.f0 > 30); ++p_45.f0)
        { /* block id: 29 */
            struct S0 *l_62 = (void*)0;
            l_63 = l_62;
        }
        l_70[2][2]++;
    }
    else
    { /* block id: 33 */
        int16_t l_75[3];
        int i;
        for (i = 0; i < 3; i++)
            l_75[i] = (-5L);
        g_2[3] = ((int16_t)p_45.f0 % (int16_t)l_75[0]);
    }
    return p_46;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i, j;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    for (i = 0; i < 5; i++)
    {
        transparent_crc(g_2[i], "g_2[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    for (i = 0; i < 4; i++)
    {
        transparent_crc(g_3[i], "g_3[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_6, "g_6", print_hash_value);
    for (i = 0; i < 3; i++)
    {
        for (j = 0; j < 2; j++)
        {
            transparent_crc(g_18[i][j], "g_18[i][j]", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    transparent_crc(g_39, "g_39", print_hash_value);
    transparent_crc(g_50.f0.f0, "g_50.f0.f0", print_hash_value);
    transparent_crc(g_64.f0, "g_64.f0", print_hash_value);
    for (i = 0; i < 6; i++)
    {
        for (j = 0; j < 3; j++)
        {
            transparent_crc(g_99[i][j], "g_99[i][j]", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    transparent_crc(g_132, "g_132", print_hash_value);
    transparent_crc(g_133, "g_133", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 34
   depth: 1, occurrence: 4
XXX total union variables: 0

XXX max expression depth: 15
breakdown:
   depth: 1, occurrence: 27
   depth: 2, occurrence: 8
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 5, occurrence: 3
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 15, occurrence: 1

XXX total number of pointers: 41

XXX times a variable address is taken: 28
XXX times a pointer is dereferenced on RHS: 1
breakdown:
   depth: 1, occurrence: 1
XXX times a pointer is dereferenced on LHS: 7
breakdown:
   depth: 1, occurrence: 7
XXX times a pointer is compared with null: 0
XXX times a pointer is compared with address of another variable: 0
XXX times a pointer is compared with another pointer: 0
XXX times a pointer is qualified to be dereferenced: 385

XXX max dereference level: 1
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 13
XXX number of pointers point to pointers: 3
XXX number of pointers point to scalars: 30
XXX number of pointers point to structs: 4
XXX percent of pointers has null in alias set: 26.8
XXX average alias set size: 1.07

XXX times a non-volatile is read: 45
XXX times a non-volatile is write: 29
XXX times a volatile is read: 3
XXX    times read thru a pointer: 0
XXX times a volatile is write: 3
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 383
XXX percentage of non-volatile access: 92.5

XXX forward jumps: 1
XXX backward jumps: 0

XXX stmts: 29
XXX max block depth: 2
breakdown:
   depth: 0, occurrence: 10
   depth: 1, occurrence: 11
   depth: 2, occurrence: 8

XXX percentage a fresh-made variable is used: 28.8
XXX percentage an existing variable is used: 71.2
********************* end of statistics **********************/

