/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.2.0
 * Git version: dcef523
 * Options:   --no-safe-math --no-math64 --no-bitfields --no-consts --no-float --no-divs --max-array-dim 2 --max-array-len-per-dim 8 --max-block-depth 2 --max-block-size 2 --max-expr-complexity 2 --max-funcs 4 --max-struct-fields 2 --max-union-fields 2 --output /specific/a/home/cc/students/cs/alonelmaliah//Desktop/avrTest/WorkFolder/avrtest.c
 * Seed:      693276704
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint32_t  f0;
};
#pragma pack(pop)

#pragma pack(push)
#pragma pack(1)
struct S1 {
   struct S0  f0;
};
#pragma pack(pop)

struct S2 {
   volatile int8_t  f0;
   int32_t  f1;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_19 = 0x00C4307EL;
static struct S2 g_24 = {0x39L,0x071A0513L};/* VOLATILE GLOBAL g_24 */
static int32_t g_28 = 0x3813BF58L;
static struct S1 g_39 = {{4294967295UL}};
static uint16_t g_42 = 0x5823L;
static struct S2 g_49[6] = {{-10L,0L},{-10L,0L},{-10L,0L},{-10L,0L},{-10L,0L},{-10L,0L}};
static struct S2 * volatile g_50 = (void*)0;/* VOLATILE GLOBAL g_50 */
static struct S2 g_51 = {0x7FL,0x9BDEFAB7L};/* VOLATILE GLOBAL g_51 */
static int32_t * volatile g_58 = &g_28;/* VOLATILE GLOBAL g_58 */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_1(void);
static uint32_t  func_6(int32_t  p_7);
static struct S0  func_14(int16_t  p_15, uint32_t  p_16, int32_t  p_17);
static uint32_t  func_22(uint16_t  p_23);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_19 g_24 g_28 g_39 g_42 g_49 g_58 g_51.f0
 * writes: g_28 g_42 g_51
 */
static int32_t  func_1(void)
{ /* block id: 0 */
    int16_t l_18[1];
    int32_t *l_60[3];
    int16_t l_61 = 0x0EF1L;
    int i;
    for (i = 0; i < 1; i++)
        l_18[i] = (-1L);
    for (i = 0; i < 3; i++)
        l_60[i] = &g_28;
    l_61 |= ((*g_58) = ((uint16_t)(((uint32_t)func_6(((int32_t)((uint16_t)(((((int8_t)(func_14(l_18[0], l_18[0], g_19) , l_18[0]) << (int8_t)5) , l_18[0]) , g_24.f1) & g_24.f1) % (uint16_t)0xE64BL) - (int32_t)0UL)) % (uint32_t)g_49[2].f1) > g_24.f1) >> (uint16_t)g_19));
    return g_51.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_42 g_49 g_58
 * writes: g_42 g_51 g_28
 */
static uint32_t  func_6(int32_t  p_7)
{ /* block id: 22 */
    uint8_t l_59 = 0x35L;
    for (g_42 = 17; (g_42 == 57); g_42 += 1)
    { /* block id: 25 */
        int16_t l_48 = 0x2177L;
        if (l_48)
            break;
        g_51 = g_49[2];
    }
    (*g_58) = ((int32_t)(((((((int8_t)((uint8_t)g_42 % (uint8_t)1L) - (int8_t)p_7) || p_7) < p_7) > p_7) & 0xD3F58F29L) || (-1L)) + (int32_t)0x7C80BFD7L);
    return l_59;
}


/* ------------------------------------------ */
/* 
 * reads : g_24 g_28 g_39 g_42
 * writes: g_28 g_42
 */
static struct S0  func_14(int16_t  p_15, uint32_t  p_16, int32_t  p_17)
{ /* block id: 1 */
    uint8_t l_20 = 0x3FL;
    struct S0 l_45 = {0x7D231D57L};
    if ((l_20 ^ p_17))
    { /* block id: 2 */
        int32_t l_26 = 0L;
        int32_t *l_27 = &g_28;
        struct S1 l_40[2][8] = {{{{6UL}},{{0xEB856A75L}},{{0xFF51885AL}},{{0xEB856A75L}},{{6UL}},{{0xEC8F9491L}},{{0xEC8F9491L}},{{6UL}}},{{{0xEB856A75L}},{{0x87E52695L}},{{0x87E52695L}},{{0xEB856A75L}},{{0x01D4C3F1L}},{{6UL}},{{0x01D4C3F1L}},{{0xEB856A75L}}}};
        int i, j;
        (*l_27) = (p_17 = (-(uint8_t)((func_22((g_24 , 0xA130L)) , p_15) , l_26)));
        if (((((((int8_t)((((uint8_t)((((int16_t)(0xE80A7C6DL <= p_16) + (int16_t)p_15) ^ p_16) > 0UL) * (uint8_t)255UL) , (*l_27)) >= (*l_27)) * (int8_t)p_15) <= l_20) && p_16) , 0L) , 0x846F2633L))
        { /* block id: 7 */
lbl_38:
            (*l_27) |= ((int16_t)(-1L) - (int16_t)p_17);
            (*l_27) |= (-(uint32_t)p_15);
        }
        else
        { /* block id: 10 */
            if (g_28)
                goto lbl_38;
            l_40[0][4] = g_39;
        }
    }
    else
    { /* block id: 14 */
        if ((p_15 > 255UL))
        { /* block id: 15 */
            int32_t *l_41[4] = {&g_28,&g_28,&g_28,&g_28};
            int i;
            ++g_42;
        }
        else
        { /* block id: 17 */
            return l_45;
        }
    }
    return l_45;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_22(uint16_t  p_23)
{ /* block id: 3 */
    int8_t l_25 = (-1L);
    return l_25;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_19, "g_19", print_hash_value);
    transparent_crc(g_24.f0, "g_24.f0", print_hash_value);
    transparent_crc(g_24.f1, "g_24.f1", print_hash_value);
    transparent_crc(g_28, "g_28", print_hash_value);
    transparent_crc(g_39.f0.f0, "g_39.f0.f0", print_hash_value);
    transparent_crc(g_42, "g_42", print_hash_value);
    for (i = 0; i < 6; i++)
    {
        transparent_crc(g_49[i].f0, "g_49[i].f0", print_hash_value);
        transparent_crc(g_49[i].f1, "g_49[i].f1", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_51.f0, "g_51.f0", print_hash_value);
    transparent_crc(g_51.f1, "g_51.f1", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 9
   depth: 1, occurrence: 4
   depth: 2, occurrence: 2
XXX total union variables: 0

XXX max expression depth: 16
breakdown:
   depth: 1, occurrence: 19
   depth: 2, occurrence: 4
   depth: 6, occurrence: 1
   depth: 9, occurrence: 1
   depth: 13, occurrence: 1
   depth: 16, occurrence: 1

XXX total number of pointers: 5

XXX times a variable address is taken: 5
XXX times a pointer is dereferenced on RHS: 2
breakdown:
   depth: 1, occurrence: 2
XXX times a pointer is dereferenced on LHS: 5
breakdown:
   depth: 1, occurrence: 5
XXX times a pointer is compared with null: 0
XXX times a pointer is compared with address of another variable: 0
XXX times a pointer is compared with another pointer: 0
XXX times a pointer is qualified to be dereferenced: 33

XXX max dereference level: 1
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 9
XXX number of pointers point to pointers: 0
XXX number of pointers point to scalars: 4
XXX number of pointers point to structs: 1
XXX percent of pointers has null in alias set: 20
XXX average alias set size: 1

XXX times a non-volatile is read: 41
XXX times a non-volatile is write: 14
XXX times a volatile is read: 1
XXX    times read thru a pointer: 0
XXX times a volatile is write: 2
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 29
XXX percentage of non-volatile access: 94.8

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 19
XXX max block depth: 2
breakdown:
   depth: 0, occurrence: 8
   depth: 1, occurrence: 5
   depth: 2, occurrence: 6

XXX percentage a fresh-made variable is used: 30
XXX percentage an existing variable is used: 70
********************* end of statistics **********************/

