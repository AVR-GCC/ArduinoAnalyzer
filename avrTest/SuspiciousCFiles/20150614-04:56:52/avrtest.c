/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.2.0
 * Git version: dcef523
 * Options:   --no-safe-math --no-math64 --no-bitfields --no-consts --no-float --no-divs --max-array-dim 2 --max-array-len-per-dim 8 --max-block-depth 2 --max-block-size 2 --max-expr-complexity 2 --max-funcs 4 --max-struct-fields 2 --max-union-fields 2 --output /specific/a/home/cc/students/cs/alonelmaliah//Desktop/avrTest/WorkFolder/avrtest.c
 * Seed:      246761676
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint8_t  f0;
};

/* --- GLOBAL VARIABLES --- */
static int16_t g_6 = 1L;
static int32_t g_13 = (-1L);
static volatile int8_t g_42 = 0x3EL;/* VOLATILE GLOBAL g_42 */
static volatile int32_t g_46 = 0x5C2C102DL;/* VOLATILE GLOBAL g_46 */
static uint32_t g_47 = 18446744073709551615UL;
static struct S0 g_51 = {0x1EL};
static struct S0 *g_54 = &g_51;
static struct S0 ** volatile g_53 = &g_54;/* VOLATILE GLOBAL g_53 */
static int8_t g_62 = 0xD6L;
static int32_t g_63 = 0x343DEF57L;
static volatile uint8_t g_81 = 247UL;/* VOLATILE GLOBAL g_81 */
static volatile uint32_t g_91 = 1UL;/* VOLATILE GLOBAL g_91 */
static uint16_t g_99[4][1] = {{0x36F4L},{0x36F4L},{0x36F4L},{0x36F4L}};
static int32_t * volatile g_106 = &g_63;/* VOLATILE GLOBAL g_106 */
static volatile int32_t g_136[8] = {0xB671196DL,0xB671196DL,0xB671196DL,0xB671196DL,0xB671196DL,0xB671196DL,0xB671196DL,0xB671196DL};
static int8_t g_138[6][1] = {{0xA6L},{0xA6L},{0xA6L},{0xA6L},{0xA6L},{0xA6L}};
static int32_t g_141 = 2L;
static int8_t g_142 = 1L;
static volatile int16_t g_143 = 9L;/* VOLATILE GLOBAL g_143 */
static volatile uint16_t g_148 = 0x6811L;/* VOLATILE GLOBAL g_148 */
static struct S0 *g_153 = &g_51;
static struct S0 ** volatile g_152 = &g_153;/* VOLATILE GLOBAL g_152 */
static uint8_t g_163 = 1UL;
static volatile int16_t g_168[5] = {0xFA70L,0xFA70L,0xFA70L,0xFA70L,0xFA70L};
static int16_t g_170 = 0L;
static int8_t g_171 = 0x9DL;
static uint8_t g_172 = 0xE6L;
static uint32_t g_176 = 0x29C145D4L;


/* --- FORWARD DECLARATIONS --- */
static struct S0  func_1(void);
static int8_t  func_2(uint8_t  p_3, uint16_t  p_4);
static int32_t * func_7(int32_t * p_8, int32_t * p_9, int32_t * p_10, int8_t  p_11);
static int32_t  func_14(int32_t * p_15, int32_t * p_16);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_6 g_13 g_47 g_53 g_46 g_51.f0 g_63 g_81 g_62 g_91 g_106 g_148 g_54 g_152 g_163 g_172 g_176 g_142
 * writes: g_6 g_13 g_47 g_54 g_62 g_63 g_51.f0 g_46 g_91 g_148 g_153 g_163 g_172 g_142
 */
static struct S0  func_1(void)
{ /* block id: 0 */
    uint32_t l_5 = 1UL;
    int8_t *l_177 = &g_142;
    int8_t *l_178 = &g_62;
    int32_t l_179 = 0L;
    int32_t *l_180 = &g_63;
    int32_t *l_181 = &l_179;
    int32_t *l_182 = &l_179;
    int32_t *l_183 = &g_13;
    int32_t *l_184 = &g_63;
    int32_t *l_185 = &g_63;
    int32_t *l_186 = &l_179;
    int32_t *l_187[7][8] = {{&g_63,&g_63,&g_13,&l_179,&g_63,&g_141,&g_63,(void*)0},{&g_13,&l_179,(void*)0,&l_179,&l_179,(void*)0,(void*)0,&g_13},{(void*)0,&l_179,&g_63,&g_63,&g_63,&g_63,&g_63,&l_179},{&g_63,(void*)0,&g_141,&g_13,&g_141,&g_13,&g_13,(void*)0},{&g_13,(void*)0,&g_63,&g_141,&g_63,&l_179,&g_13,&g_63},{(void*)0,&g_141,&g_141,&g_13,(void*)0,&g_13,&g_13,(void*)0},{(void*)0,&g_13,&g_13,(void*)0,&g_13,&g_141,&g_141,(void*)0}};
    uint16_t l_188 = 4UL;
    struct S0 l_191 = {255UL};
    int i, j;
    l_179 = ((((*l_178) = (((*l_177) |= (func_2(l_5, g_6) , g_176)) <= l_5)) != (-1L)) <= 65535UL);
    l_188--;
    return l_191;
}


/* ------------------------------------------ */
/* 
 * reads : g_6 g_13 g_47 g_53 g_46 g_51.f0 g_63 g_81 g_62 g_91 g_106 g_148 g_54 g_152 g_163 g_172
 * writes: g_6 g_13 g_47 g_54 g_62 g_63 g_51.f0 g_46 g_91 g_148 g_153 g_163 g_172
 */
static int8_t  func_2(uint8_t  p_3, uint16_t  p_4)
{ /* block id: 1 */
    int32_t *l_12 = &g_13;
    int8_t l_94[8][7] = {{0L,0xF9L,(-1L),0xF9L,0L,(-1L),9L},{0x83L,0x5DL,(-1L),0x83L,(-1L),0x5DL,0x83L},{0x07L,9L,0x8BL,5L,9L,5L,0x8BL},{0x83L,0x83L,1L,0xCFL,0x5DL,1L,0x5DL},{0L,0x8BL,0x8BL,0L,5L,0x07L,0L},{6L,0x5DL,(-1L),(-1L),0x5DL,6L,0x5DL},{0xF9L,0L,(-1L),9L,9L,(-1L),0L},{0x5DL,0x5DL,6L,0x5DL,(-1L),(-1L),0x5DL}};
    int32_t l_117 = 0xED4C97A6L;
    int32_t l_137 = 0xCD18219FL;
    int32_t l_139 = (-1L);
    int32_t l_140 = (-1L);
    int32_t l_144 = (-6L);
    int32_t l_145 = 4L;
    int16_t l_146 = (-1L);
    int i, j;
lbl_175:
    l_12 = func_7(l_12, l_12, l_12, p_3);
    for (g_6 = 6; (g_6 >= 1); g_6 -= 1)
    { /* block id: 56 */
        int8_t l_97 = 0x0CL;
        int32_t l_102 = (-6L);
        int8_t l_133 = 0x94L;
        int32_t l_135[6] = {0xFC1B3DFEL,0xFC1B3DFEL,0xFC1B3DFEL,0xFC1B3DFEL,0xFC1B3DFEL,0xFC1B3DFEL};
        int32_t *l_154 = &g_141;
        int32_t *l_155 = &l_140;
        int32_t *l_156 = &l_145;
        int32_t *l_157 = &l_135[2];
        int32_t *l_158 = (void*)0;
        int32_t *l_159 = &l_137;
        int32_t *l_160 = (void*)0;
        int32_t *l_161 = &l_144;
        int32_t *l_162[3][1];
        int8_t l_166[1];
        int i, j;
        for (i = 0; i < 3; i++)
        {
            for (j = 0; j < 1; j++)
                l_162[i][j] = &l_144;
        }
        for (i = 0; i < 1; i++)
            l_166[i] = 0L;
        if (((uint16_t)((-1L) | l_97) + (uint16_t)0x6600L))
        { /* block id: 57 */
            uint16_t *l_98[5] = {&g_99[3][0],&g_99[3][0],&g_99[3][0],&g_99[3][0],&g_99[3][0]};
            int32_t l_105 = 0x86717EFFL;
            int i;
            (*g_106) |= (((l_102 = (++p_4)) , (l_105 = (((uint16_t)(*l_12) + (uint16_t)65527UL) == (*l_12)))) != 0xB9CEL);
            l_105 &= (0x7FF9E38BL & p_4);
        }
        else
        { /* block id: 63 */
            int32_t *l_107 = &g_63;
            int32_t *l_108 = &l_102;
            int32_t *l_109 = &l_102;
            int32_t *l_110 = &g_13;
            int32_t *l_111 = &l_102;
            int32_t *l_112 = &g_63;
            int32_t *l_113 = &g_63;
            int32_t *l_114 = &l_102;
            int32_t *l_115 = &g_63;
            int32_t *l_116 = &l_102;
            int32_t *l_118 = &g_63;
            int32_t l_119 = (-1L);
            int32_t *l_120 = &g_63;
            int32_t *l_121 = &g_13;
            int32_t *l_122 = (void*)0;
            int32_t *l_123 = (void*)0;
            int32_t *l_124 = &g_63;
            int32_t *l_125 = &g_13;
            int32_t l_126 = 0x82763D23L;
            int32_t *l_127 = &l_119;
            int32_t *l_128 = &g_13;
            int32_t *l_129 = &l_117;
            int32_t *l_130 = &g_13;
            int32_t *l_131[1][6];
            int8_t l_132 = (-10L);
            int16_t l_134 = (-3L);
            int16_t l_147 = 1L;
            struct S0 **l_151 = &g_54;
            int i, j;
            for (i = 0; i < 1; i++)
            {
                for (j = 0; j < 6; j++)
                    l_131[i][j] = &l_117;
            }
            g_148--;
            (*g_152) = ((*l_151) = (*g_53));
        }
        g_163--;
        for (l_145 = 2; (l_145 <= 6); l_145 += 1)
        { /* block id: 71 */
            int16_t l_167 = (-7L);
            int32_t l_169 = 1L;
            g_172++;
            if (l_145)
                goto lbl_175;
        }
    }
    return p_3;
}


/* ------------------------------------------ */
/* 
 * reads : g_6 g_13 g_47 g_53 g_46 g_51.f0 g_63 g_81 g_62 g_91
 * writes: g_6 g_13 g_47 g_54 g_62 g_63 g_51.f0 g_46 g_91
 */
static int32_t * func_7(int32_t * p_8, int32_t * p_9, int32_t * p_10, int8_t  p_11)
{ /* block id: 2 */
    uint32_t l_17 = 0x6F93BD5DL;
    int32_t *l_19 = (void*)0;
    int32_t **l_18 = &l_19;
    uint32_t l_82 = 1UL;
    int32_t *l_86 = &g_63;
    int32_t l_87 = 0L;
    int32_t *l_88 = &g_63;
    int32_t *l_89 = &g_63;
    int32_t *l_90[2][4] = {{&l_87,&l_87,&l_87,&l_87},{&l_87,&l_87,&l_87,&l_87}};
    int i, j;
    if (func_14(((*l_18) = ((l_17 = 0x9B6917ABL) , (void*)0)), p_9))
    { /* block id: 37 */
        for (g_63 = 0; (g_63 >= 18); g_63 += 4)
        { /* block id: 40 */
            return p_8;
        }
    }
    else
    { /* block id: 43 */
        uint32_t l_83 = 0xF72093AAL;
        for (g_13 = 0; (g_13 == 15); g_13++)
        { /* block id: 46 */
            g_46 = ((((uint16_t)(((uint8_t)((((int8_t)(((int8_t)((int8_t)0x2FL - (int8_t)249UL) % (int8_t)1UL) != 0x0D08L) % (int8_t)g_81) <= 0x41AEL) & g_6) >> (uint8_t)0) , 0x22AAL) >> (uint16_t)l_82) != g_6) || g_62);
        }
        l_83--;
    }
    g_91++;
    return &g_13;
}


/* ------------------------------------------ */
/* 
 * reads : g_6 g_13 g_47 g_53 g_46 g_51.f0 g_63
 * writes: g_6 g_13 g_47 g_54 g_62 g_63 g_51.f0
 */
static int32_t  func_14(int32_t * p_15, int32_t * p_16)
{ /* block id: 5 */
    int32_t *l_25 = &g_13;
    uint8_t l_34 = 0UL;
    int32_t l_35[7][8] = {{0L,0xA7C76986L,1L,0L,0xE7BAA9D7L,0xF5D1CC0CL,0xBFBC35CFL,(-9L)},{0x07C1ABDFL,9L,1L,0x99E1F953L,0xBFE6B87CL,0L,0L,0xBFE6B87CL},{0xE7BAA9D7L,0x07C1ABDFL,0x07C1ABDFL,0xE7BAA9D7L,0x939C0105L,0L,0xB13B1067L,0xBFBC35CFL},{0x99E1F953L,1L,9L,0x07C1ABDFL,0L,0x763523E2L,1L,0L},{0L,1L,0xA7C76986L,0L,9L,0L,9L,0L},{(-9L),0x07C1ABDFL,(-9L),0xB2EC6F0DL,0xFD579DEBL,0L,0xE7BAA9D7L,9L},{0x939C0105L,9L,0x99E1F953L,(-1L),0x07C1ABDFL,0xF5D1CC0CL,0xFD579DEBL,1L}};
    uint32_t l_43 = 0xC2DB6027L;
    int i, j;
    for (g_6 = 10; (g_6 <= 1); --g_6)
    { /* block id: 8 */
        for (g_13 = (-15); (g_13 > (-24)); --g_13)
        { /* block id: 11 */
            uint8_t l_24 = 0x96L;
            if (l_24)
                break;
            if (g_13)
                continue;
        }
    }
    if (((void*)0 != l_25))
    { /* block id: 16 */
        int8_t l_33 = 0xD8L;
        int32_t l_36 = (-8L);
        int32_t l_41 = 0x23541209L;
        struct S0 *l_52 = &g_51;
        int32_t **l_55 = &l_25;
        if ((((uint16_t)(~((uint8_t)((uint8_t)(l_33 | g_13) + (uint8_t)8L) % (uint8_t)l_34)) >> (uint16_t)g_6) > 0x1CB64B69L))
        { /* block id: 17 */
            int32_t *l_37 = &g_13;
            int32_t *l_38 = &l_35[4][6];
            int32_t *l_39 = &l_36;
            int32_t *l_40[3];
            int i;
            for (i = 0; i < 3; i++)
                l_40[i] = (void*)0;
            l_43++;
            ++g_47;
        }
        else
        { /* block id: 20 */
            struct S0 *l_50 = &g_51;
            l_52 = l_50;
            (*g_53) = l_52;
        }
        p_16 = ((*l_55) = (void*)0);
    }
    else
    { /* block id: 26 */
        int8_t *l_60 = (void*)0;
        int8_t *l_61[5];
        int32_t l_64 = (-1L);
        int i;
        for (i = 0; i < 5; i++)
            l_61[i] = &g_62;
        (*l_25) = ((((g_63 = ((int8_t)(g_62 = ((int16_t)(g_46 ^ (*l_25)) >> (int16_t)1)) >> (int8_t)(*l_25))) , 0x53L) ^ l_64) > (*p_16));
        for (g_51.f0 = 0; (g_51.f0 <= 15); g_51.f0 += 6)
        { /* block id: 32 */
            (*p_16) = (g_63 || g_63);
        }
    }
    return g_46;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i, j;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_6, "g_6", print_hash_value);
    transparent_crc(g_13, "g_13", print_hash_value);
    transparent_crc(g_42, "g_42", print_hash_value);
    transparent_crc(g_46, "g_46", print_hash_value);
    transparent_crc(g_47, "g_47", print_hash_value);
    transparent_crc(g_51.f0, "g_51.f0", print_hash_value);
    transparent_crc(g_62, "g_62", print_hash_value);
    transparent_crc(g_63, "g_63", print_hash_value);
    transparent_crc(g_81, "g_81", print_hash_value);
    transparent_crc(g_91, "g_91", print_hash_value);
    for (i = 0; i < 4; i++)
    {
        for (j = 0; j < 1; j++)
        {
            transparent_crc(g_99[i][j], "g_99[i][j]", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    for (i = 0; i < 8; i++)
    {
        transparent_crc(g_136[i], "g_136[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    for (i = 0; i < 6; i++)
    {
        for (j = 0; j < 1; j++)
        {
            transparent_crc(g_138[i][j], "g_138[i][j]", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    transparent_crc(g_141, "g_141", print_hash_value);
    transparent_crc(g_142, "g_142", print_hash_value);
    transparent_crc(g_143, "g_143", print_hash_value);
    transparent_crc(g_148, "g_148", print_hash_value);
    transparent_crc(g_163, "g_163", print_hash_value);
    for (i = 0; i < 5; i++)
    {
        transparent_crc(g_168[i], "g_168[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_170, "g_170", print_hash_value);
    transparent_crc(g_171, "g_171", print_hash_value);
    transparent_crc(g_172, "g_172", print_hash_value);
    transparent_crc(g_176, "g_176", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 58
   depth: 1, occurrence: 1
XXX total union variables: 0

XXX max expression depth: 12
breakdown:
   depth: 1, occurrence: 37
   depth: 2, occurrence: 12
   depth: 3, occurrence: 1
   depth: 5, occurrence: 1
   depth: 6, occurrence: 2
   depth: 8, occurrence: 1
   depth: 9, occurrence: 2
   depth: 12, occurrence: 1

XXX total number of pointers: 71

XXX times a variable address is taken: 82
XXX times a pointer is dereferenced on RHS: 6
breakdown:
   depth: 1, occurrence: 6
XXX times a pointer is dereferenced on LHS: 10
breakdown:
   depth: 1, occurrence: 10
XXX times a pointer is compared with null: 1
XXX times a pointer is compared with address of another variable: 0
XXX times a pointer is compared with another pointer: 0
XXX times a pointer is qualified to be dereferenced: 544

XXX max dereference level: 1
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 25
XXX number of pointers point to pointers: 5
XXX number of pointers point to scalars: 62
XXX number of pointers point to structs: 4
XXX percent of pointers has null in alias set: 15.5
XXX average alias set size: 1.08

XXX times a non-volatile is read: 49
XXX times a non-volatile is write: 41
XXX times a volatile is read: 4
XXX    times read thru a pointer: 0
XXX times a volatile is write: 6
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 48
XXX percentage of non-volatile access: 90

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 38
XXX max block depth: 2
breakdown:
   depth: 0, occurrence: 12
   depth: 1, occurrence: 11
   depth: 2, occurrence: 15

XXX percentage a fresh-made variable is used: 39.9
XXX percentage an existing variable is used: 60.1
********************* end of statistics **********************/

