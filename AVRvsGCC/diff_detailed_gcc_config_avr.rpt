diff -r avr/gcc/config/avr/avr.c gcc/gcc/config/avr/avr.c
80,90d79
< #define TINY_ADIW(REG1, REG2, I)                                \
<     "subi " #REG1 ",lo8(-(" #I "))" CR_TAB                        \
<     "sbci " #REG2 ",hi8(-(" #I "))"        
< 
< #define TINY_SBIW(REG1, REG2, I)                                \
<     "subi " #REG1 ",lo8((" #I "))" CR_TAB                         \
<     "sbci " #REG2 ",hi8((" #I "))"        
< 
< #define AVR_TMP_REGNO (AVR_TINY ? TMP_REGNO_TINY : TMP_REGNO)
< #define AVR_ZERO_REGNO (AVR_TINY ? ZERO_REGNO_TINY : ZERO_REGNO)
< 
159,161d147
< /* Last call saved register */
< #define LAST_CALLEE_SAVED_REG (AVR_TINY ? 19 : 17)
< 
341c327
<   avr_addr.ccp = (AVR_TINY ? 0x3C : 0x34) + avr_current_arch->sfr_offset;
---
>   avr_addr.ccp = 0x34 + avr_current_arch->sfr_offset;
349,351d334
<   if (!global_options_set.x_dwarf_version)
<     dwarf_version = 2;
< 
376,377c359,360
<   tmp_reg_rtx  = all_regs_rtx[AVR_TMP_REGNO];
<   zero_reg_rtx = all_regs_rtx[AVR_ZERO_REGNO];
---
>   tmp_reg_rtx  = all_regs_rtx[TMP_REGNO];
>   zero_reg_rtx = all_regs_rtx[ZERO_REGNO];
389,393d371
< 
<   /* TINY core does not have regs r10-r16, but avr-dimode.md expects them
<      to be present */
<   if (AVR_TINY)
<     avr_have_dimode = false; 
539,547d516
< /* Return nonzero if FUNC is an nmi function as specified
<    by the "nmi" attribute.  */
< 
< static int
< avr_nmi_function_p (tree func)
< {
<   return avr_lookup_function_attribute1 (func, "nmi");
< }
< 
595d563
<   cfun->machine->is_nmi = avr_nmi_function_p (decl);
599,604c567
<   if (cfun->machine->is_interrupt)
<     isr = "interrupt";
<   else if (cfun->machine->is_nmi)
<     isr = "nmi";
<   else
<     isr = "signal";
---
>   isr = cfun->machine->is_interrupt ? "interrupt" : "signal";
609,610c572
<       + (cfun->machine->is_signal || cfun->machine->is_interrupt 
<           || cfun->machine->is_nmi) > 1)
---
>       + (cfun->machine->is_signal || cfun->machine->is_interrupt) > 1)
621,622c583
<   if (cfun->machine->is_interrupt || cfun->machine->is_signal 
<           || cfun->machine->is_nmi)
---
>   if (cfun->machine->is_interrupt || cfun->machine->is_signal)
626,631c587
<       const char *name;
< 
<       name = DECL_ASSEMBLER_NAME_SET_P (decl)
<         /* Remove the leading '*' added in set_user_assembler_name.  */
<         ? 1 + IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl))
<         : IDENTIFIER_POINTER (DECL_NAME (decl));
---
>       const char *name = IDENTIFIER_POINTER (DECL_NAME (decl));
918c874
<   for (reg = 0; reg <= LAST_CALLEE_SAVED_REG; ++reg)
---
>   for (reg = 0; reg < 18; ++reg)
1030c986
<   emit_push_byte (AVR_TMP_REGNO, frame_related_p);
---
>   emit_push_byte (TMP_REGNO, frame_related_p);
1056,1057c1012
<                    && !cfun->machine->is_OS_main
<                    && !AVR_TINY);
---
>                    && !cfun->machine->is_OS_main);
1094c1049
<       first_reg = (LAST_CALLEE_SAVED_REG + 1) - (live_seq - 2);
---
>       first_reg = 18 - (live_seq - 2);
1098c1053
<            reg = (reg == 28 ? LAST_CALLEE_SAVED_REG : reg - 1), ++offset)
---
>            reg = (reg == 28 ? 17 : reg - 1), ++offset)
1160c1115
<           HOST_WIDE_INT size_cfa = size, neg_size;
---
>           HOST_WIDE_INT size_cfa = size;
1199d1153
<           neg_size = trunc_int_for_mode (-size, GET_MODE (my_fp));
1220,1221c1174
<                                                        my_fp, neg_size));
< 
---
>                                                        my_fp, -size));
1337c1290
<       emit_push_byte (AVR_ZERO_REGNO, true);
---
>       emit_push_byte (ZERO_REGNO, true);
1340c1293
<       emit_push_byte (AVR_TMP_REGNO, true);
---
>       emit_push_byte (TMP_REGNO, true);
1482,1483c1435
<               && !cfun->machine->is_OS_main
<               && !AVR_TINY);
---
>               && !cfun->machine->is_OS_main);
1641c1593
<       emit_pop_byte (AVR_TMP_REGNO);
---
>       emit_pop_byte (TMP_REGNO);
1645c1597
<       emit_pop_byte (AVR_TMP_REGNO);
---
>       emit_pop_byte (TMP_REGNO);
1648c1600
<       emit_pop_byte (AVR_ZERO_REGNO);
---
>       emit_pop_byte (ZERO_REGNO);
2130c2082
<   int abcd = 0, ef = 0, ij = 0;
---
>   int abcd = 0;
2134,2137d2085
<   else if (code == 'E' || code == 'F')
<     ef = code - 'E';
<   else if (code == 'I' || code == 'J')
<     ij = code - 'I';
2174,2183d2121
<   else if (code == 'E' || code == 'F')
<     {
<       rtx op = XEXP(x, 0);
<       fprintf (file, reg_names[REGNO (op) + ef]);
<     }
<   else if (code == 'I' || code == 'J')
<     {
<       rtx op = XEXP(XEXP(x, 0), 0);
<       fprintf (file, reg_names[REGNO (op) + ij]);
<     }
2210c2148
<           else if ((AVR_XMEGA || AVR_TINY) && ival == avr_addr.ccp)
---
>           else if (AVR_XMEGA && ival == avr_addr.ccp)
2253,2259d2190
<       else if (code == 'b')
<         {
<           if (GET_CODE (addr) != PLUS)
<                fatal_insn ("bad address, not (reg+disp):", addr);
< 
<           avr_print_operand_address (file, XEXP (addr, 0));
<         }
2607c2538
<   return (AVR_TINY ? r >= 20 && r <= 25 : r >= 8 && r <= 25);
---
>   return (r >= 8 && r <= 25);
2619c2550
<   cum->nregs = AVR_TINY ? 6 : 18;
---
>   cum->nregs = 18;
3144c3075,3076
<   avr_asm_len (AVR_HAVE_LPMX ? "lpm %3,%a2" : "lpm", xop, plen, -1);
---
>   if (plen)
>     *plen = 0;
3147c3079,3082
<                "ld %3,%a2", xop, plen, 2);
---
>                "ld %3,%a2" CR_TAB
>                "sbrs %1,7", xop, plen, 3);
> 
>   avr_asm_len (AVR_HAVE_LPMX ? "lpm %3,%a2" : "lpm", xop, plen, 1);
3155,3196d3089
< /*
< The range check is needed only if the device has SRAM greater than
< LDS/STS range. Only attiny40 has that much SRAM and needs special
< consideration. Also include avrtiny, as code compiled for avrtiny is
< supposed to work for all devices in the arch.
< */
< static bool tiny_device_has_out_of_range_sram ()
< {
<     return AVR_TINY &&
<         (strcmp (avr_current_device->name, "attiny40") == 0
<          ||  strcmp (avr_current_device->name, "avrtiny") == 0);
< }
< 
< /*
< AVRTC-579
< if operand is symbol or constant expression with value > 0xbf
<   return false, otherwise true
< This check is used to avoid lds/sts instruction with invalid memory
< access range (valid range 0x40..0xbf). For io operand range 0x0..0x3f,
< in/out instruction will be generated.
< */
< bool tiny_valid_direct_memory_access_range(rtx op, enum machine_mode mode)
< {
<   rtx x;
< 
<   if (!AVR_TINY)
<     return true;
< 
<   x = XEXP(op,0);
< 
<   if (MEM_P(op) && x && (GET_CODE(x) == SYMBOL_REF))
<   {
<     return !tiny_device_has_out_of_range_sram ();
<   }
<   if (MEM_P(op) && x && (CONSTANT_ADDRESS_P (x)) &&
<      !(IN_RANGE (INTVAL (x), 0, 0xC0 - GET_MODE_SIZE (mode))))
<   {
<     return false;
<   }
< 
<   return true;
< }
3325,3342d3217
< /* Same as out_movqi_r_mr, but TINY does not have ADIW or SBIW */
< static const char*
< avr_out_movqi_r_mr_reg_disp_tiny (rtx insn, rtx op[], int *plen)
< {
<   rtx dest = op[0];
<   rtx src = op[1];
<   rtx x = XEXP (src, 0);
< 
<   avr_asm_len (TINY_ADIW (%I1, %J1, %o1) CR_TAB
<           "ld %0,%b1" , op, plen, -3);
< 
<   if (!reg_overlap_mentioned_p (dest, XEXP (x,0))
<           && !reg_unused_after (insn, XEXP (x,0)))
<       avr_asm_len (TINY_SBIW (%I1, %J1, %o1), op, plen, 2);
< 
<   return "";
< }
< 
3352d3226
<       int n_words = AVR_TINY ? 1 : 2;
3355c3229
<         : avr_asm_len ("lds %0,%m1", op, plen, -n_words);
---
>         : avr_asm_len ("lds %0,%m1", op, plen, -2);
3357,3358c3231
< 
<   if (GET_CODE (x) == PLUS
---
>   else if (GET_CODE (x) == PLUS
3366,3368d3238
<       if (AVR_TINY)
<         return avr_out_movqi_r_mr_reg_disp_tiny (insn, op, plen);
< 
3408,3483d3277
< /* Same as movhi_r_mr, but TINY does not have ADIW, SBIW and LDD */
< static const char*
< avr_out_movhi_r_mr_reg_no_disp_tiny (rtx op[], int *plen)
< {
<   rtx dest = op[0];
<   rtx src = op[1];
<   rtx base = XEXP (src, 0);
< 
<   int reg_dest = true_regnum (dest);
<   int reg_base = true_regnum (base);
< 
<   if (reg_dest == reg_base)         /* R = (R) */
<       return avr_asm_len ("ld __tmp_reg__,%1+" CR_TAB
<               "ld %B0,%1"          CR_TAB
<               "mov %A0,__tmp_reg__", op, plen, -3);
< 
<   return avr_asm_len ("ld %A0,%1"             CR_TAB                        
<           TINY_ADIW (%E1, %F1, 1) CR_TAB                       
<           "ld %B0,%1"             CR_TAB                        
<           TINY_SBIW (%E1, %F1, 1), op, plen, -6);
< 
< }
< 
< /* Same as movhi_r_mr, but TINY does not have ADIW, SBIW and LDD */
< static const char*
< avr_out_movhi_r_mr_reg_disp_tiny (rtx op[], int *plen)
< {
<   rtx dest = op[0];
<   rtx src = op[1];
<   rtx base = XEXP (src, 0);
< 
<   int reg_dest = true_regnum (dest);
<   int reg_base = true_regnum (XEXP (base, 0));
< 
<   if (reg_base == reg_dest)
<   {
<       return avr_asm_len (TINY_ADIW (%I1, %J1, %o1) CR_TAB
<               "ld __tmp_reg__,%b1+"    CR_TAB
<               "ld %B0,%b1"             CR_TAB 
<               "mov %A0,__tmp_reg__", op, plen, -5);
<   }
<   else
<   {
<       return avr_asm_len (TINY_ADIW (%I1, %J1, %o1) CR_TAB
<               "ld %A0,%b1+"             CR_TAB
<               "ld %B0,%b1"              CR_TAB
<               TINY_SBIW (%I1, %J1, %o1+1), op, plen, -6);
<   }
< } 
< 
< /* Same as movhi_r_mr, but TINY does not have ADIW, SBIW and LDD */
< static const char*
< avr_out_movhi_r_mr_pre_dec_tiny (rtx insn, rtx op[], int *plen)
< {
<   int mem_volatile_p = 0;
<   rtx dest = op[0];
<   rtx src = op[1];
<   rtx base = XEXP (src, 0);
< 
<   /* "volatile" forces reading low byte first, even if less efficient,
<      for correct operation with 16-bit I/O registers.  */
<   mem_volatile_p = MEM_VOLATILE_P (src);
< 
<   if (reg_overlap_mentioned_p (dest, XEXP (base, 0)))
<       fatal_insn ("incorrect insn:", insn);
< 
<   if (!mem_volatile_p)
<       return avr_asm_len ("ld %B0,%1" CR_TAB
<               "ld %A0,%1", op, plen, -2);
< 
<   return avr_asm_len (TINY_SBIW (%I1, %J1, 2)  CR_TAB
<           "ld %A0,%p1+"   CR_TAB
<           "ld %B0,%p1"    CR_TAB
<           TINY_SBIW (%I1, %J1, 1), op, plen, -6);
< }
< 
3498,3500d3291
<       if (AVR_TINY)
<         return avr_out_movhi_r_mr_reg_no_disp_tiny (op, plen);
< 
3523,3525d3313
<       if (AVR_TINY)
<         return avr_out_movhi_r_mr_reg_disp_tiny (op, plen);
< 
3537c3325
<               : avr_asm_len ("subi r28,lo8(-%o1)" CR_TAB
---
>             : avr_asm_len ("subi r28,lo8(-%o1)" CR_TAB
3571,3573d3358
<       if (AVR_TINY)
<           return avr_out_movhi_r_mr_pre_dec_tiny (insn, op, plen);
< 
3601d3385
<       int n_words = AVR_TINY ? 2 : 4;
3607c3391
<                        "lds %B0,%m1+1", op, plen, -n_words);
---
>                        "lds %B0,%m1+1", op, plen, -4);
3615,3707d3398
< avr_out_movsi_r_mr_reg_no_disp_tiny (rtx insn, rtx op[], int *l)
< {
<   rtx dest = op[0];
<   rtx src = op[1];
<   rtx base = XEXP (src, 0);
<   int reg_dest = true_regnum (dest);
<   int reg_base = true_regnum (base);
< 
<   if (reg_dest == reg_base)
<     {
< 	  /* "ld r26,-X" is undefined */
<       return *l=9, (TINY_ADIW (%E1, %F1, 3) CR_TAB
<                     "ld %D0,%1"             CR_TAB
<                     "ld %C0,-%1"            CR_TAB
<                     "ld __tmp_reg__,-%1"   CR_TAB
<                     TINY_SBIW (%E1, %F1, 1) CR_TAB
<                     "ld %A0,%1"             CR_TAB
<                     "mov %B0,__tmp_reg__");
<     }
<   else if (reg_dest == reg_base - 2)
<     {
<       return *l=5, ("ld %A0,%1+"            CR_TAB
<                     "ld %B0,%1+"            CR_TAB
<                     "ld __tmp_reg__,%1+"   CR_TAB
<                     "ld %D0,%1"            CR_TAB
<                     "mov %C0,__tmp_reg__");
<     }
<   else if (reg_unused_after (insn, base))
<     {
<       return *l=4, ("ld %A0,%1+"    CR_TAB
<                     "ld %B0,%1+"    CR_TAB 
<                     "ld %C0,%1+"    CR_TAB
<                     "ld %D0,%1");
<     }
<   else
<     {
<       return *l=6, ("ld %A0,%1+"    CR_TAB
<                     "ld %B0,%1+"    CR_TAB 
<                     "ld %C0,%1+"    CR_TAB
<                     "ld %D0,%1"     CR_TAB
<                     TINY_SBIW (%E1, %F1, 3));
<     }
< }
< 
< static const char*
< avr_out_movsi_r_mr_reg_disp_tiny (rtx insn, rtx op[], int *l)
< {
<   rtx dest = op[0];
<   rtx src = op[1];
<   rtx base = XEXP (src, 0);
<   int reg_dest = true_regnum (dest);
<   int reg_base = true_regnum (XEXP (base, 0));
< 
<   if (reg_dest == reg_base)
<     {
< 	  /* "ld r26,-X" is undefined */
<       return *l=9, (TINY_ADIW (%I1, %J1, %o1+3) CR_TAB
<                     "ld %D0,%b1"                 CR_TAB
<                     "ld %C0,-%b1"                CR_TAB
<                     "ld __tmp_reg__,-%b1"        CR_TAB
<                     TINY_SBIW (%I1, %J1, 1)     CR_TAB
<                     "ld %A0,%b1"                 CR_TAB
<                     "mov %B0,__tmp_reg__");
<     }
<   else if (reg_dest == reg_base - 2)
<     {
<       return *l=7, (TINY_ADIW (%I1, %J1, %o1) CR_TAB
<                     "ld %A0,%b1+"              CR_TAB
<                     "ld %B0,%b1+"              CR_TAB
<                     "ld __tmp_reg__,%b1+"      CR_TAB
<                     "ld %D0,%b1"               CR_TAB
<                     "mov %C0,__tmp_reg__");
<     }
<   else if (reg_unused_after (insn, XEXP (base, 0)))
<     {
<       return *l=6, (TINY_ADIW (%I1, %J1, %o1) CR_TAB
<                     "ld %A0,%b1+"              CR_TAB
<                     "ld %B0,%b1+"              CR_TAB 
<                     "ld %C0,%b1+"              CR_TAB
<                     "ld %D0,%b1");
<     }
<   else
<     {
<       return *l=8, (TINY_ADIW (%I1, %J1, %o1) CR_TAB
<                     "ld %A0,%b1+"              CR_TAB
<                     "ld %B0,%b1+"              CR_TAB 
<                     "ld %C0,%b1+"              CR_TAB
<                     "ld %D0,%b1"               CR_TAB
<                     TINY_SBIW (%I1, %J1, %o1+3));
<     }
< }
< 
< static const char*
3722,3724d3412
<       if (AVR_TINY)
<         return avr_out_movsi_r_mr_reg_no_disp_tiny (insn, op, l);
< 
3779,3781d3466
<       if (AVR_TINY)
<         return avr_out_movsi_r_mr_reg_disp_tiny (insn, op, l);
< 
3865,3877c3550
<     {
<       if (io_address_operand (base, SImode))
<         {
<           *l = 4;
<           return ("in %A0,%i1"   CR_TAB
<                   "in %B0,%i1+1" CR_TAB
<                   "in %C0,%i1+2" CR_TAB
<                   "in %D0,%i1+3");
<         }
<       else
<         {
<           *l = AVR_TINY ? 4 : 8;
<           return ("lds %A0,%m1"   CR_TAB
---
>     return *l=8, ("lds %A0,%m1"   CR_TAB
3881,3882d3553
<         }
<     }
3889,3992d3559
< avr_out_movsi_mr_r_reg_no_disp_tiny (rtx insn, rtx op[], int *l)
< {
<   rtx dest = op[0];
<   rtx src = op[1];
<   rtx base = XEXP (dest, 0);
<   int reg_base = true_regnum (base);
<   int reg_src = true_regnum (src);
<   
<   if (reg_base == reg_src)
<     {
< 	  /* "ld r26,-X" is undefined */
<       if (reg_unused_after (insn, base))
<         { 
<           return *l=7, ("mov __tmp_reg__, %B1"  CR_TAB
<                         "st %0,%A1"             CR_TAB
<                         TINY_ADIW (%E0, %F0, 1) CR_TAB
<                         "st %0+,__tmp_reg__"    CR_TAB
<                         "st %0+,%C1"            CR_TAB
<                         "st %0+,%D1");
<         }
<       else
<         {
<           return *l=9, ("mov __tmp_reg__, %B1"  CR_TAB
<                         "st %0,%A1"             CR_TAB
<                         TINY_ADIW (%E0, %F0, 1) CR_TAB
<                         "st %0+,__tmp_reg__"    CR_TAB
<                         "st %0+,%C1"            CR_TAB
<                         "st %0+,%D1"            CR_TAB
<                         TINY_SBIW (%E0, %F0, 3));
<         }
<     }
<     else if (reg_base == reg_src + 2)
<       {
<         if (reg_unused_after (insn, base))
<           return *l=7, ("mov __zero_reg__,%C1" CR_TAB
<                         "mov __tmp_reg__,%D1"  CR_TAB
<                         "st %0+,%A1"           CR_TAB
<                         "st %0+,%B1"           CR_TAB
<                         "st %0+,__zero_reg__"  CR_TAB
<                         "st %0,__tmp_reg__"    CR_TAB
<                         "clr __zero_reg__");
<         else
<           return *l=9, ("mov __zero_reg__,%C1" CR_TAB
<                         "mov __tmp_reg__,%D1"  CR_TAB
<                         "st %0+,%A1"           CR_TAB
<                         "st %0+,%B1"           CR_TAB
<                         "st %0+,__zero_reg__"  CR_TAB
<                         "st %0,__tmp_reg__"    CR_TAB
<                         "clr __zero_reg__"     CR_TAB
<                         TINY_SBIW (%E0, %F0, 3));
<       }
< 
<     return *l=6, ("st %0+,%A1" CR_TAB
<                   "st %0+,%B1" CR_TAB
<                   "st %0+,%C1" CR_TAB
<                   "st %0,%D1"  CR_TAB
<                   TINY_SBIW (%E0, %F0, 3));
< }
< 
< static const char*
< avr_out_movsi_mr_r_reg_disp_tiny (rtx op[], int *l)
< {
<   rtx dest = op[0];
<   rtx src = op[1];
<   rtx base = XEXP (dest, 0);
<   int reg_base = REGNO (XEXP (base, 0));
<   int reg_src =true_regnum (src);
< 
<   if (reg_base == reg_src)
<     {
< 	  *l = 11;
< 	  return ("mov __tmp_reg__,%A2"        CR_TAB
< 		      "mov __zero_reg__,%B2"       CR_TAB
<               TINY_ADIW (%I0, %J0, %o0)    CR_TAB
< 		      "st %b0+,__tmp_reg__"        CR_TAB
< 		      "st %b0+,__zero_reg__"       CR_TAB
< 		      "st %b0+,%C2"                CR_TAB
< 		      "st %b0,%D2"                 CR_TAB
< 		      "clr __zero_reg__"           CR_TAB
< 		      TINY_SBIW (%I0, %J0, %o0+3));
< 	 }
<   else if (reg_src == reg_base - 2)
<     {
< 	  *l = 11;
< 	  return ("mov __tmp_reg__,%C2"         CR_TAB
< 		      "mov __zero_reg__,%D2"        CR_TAB
< 		      TINY_ADIW (%I0, %J0, %o0)     CR_TAB
< 		      "st %b0+,%A0"                 CR_TAB
< 		      "st %b0+,%B0"                 CR_TAB
< 		      "st %b0+,__tmp_reg__"         CR_TAB
< 		      "st %b0,__zero_reg__"         CR_TAB
< 		      "clr __zero_reg__"            CR_TAB
< 		      TINY_SBIW (%I0, %J0, %o0+3));
< 	    }
<   *l = 8;
<   return (TINY_ADIW (%I0, %J0, %o0)     CR_TAB
< 		  "st %b0+,%A1"                 CR_TAB
< 		  "st %b0+,%B1"                 CR_TAB
< 		  "st %b0+,%C1"                 CR_TAB
< 		  "st %b0,%D1"                  CR_TAB
< 		  TINY_SBIW (%I0, %J0, %o0+3));
< }
< 
< static const char*
4006,4023c3573,3576
<     {
<       if (io_address_operand (base, SImode))
<         {
<           return *l=4,("out %i0, %A1"  CR_TAB
<                        "out %i0+1,%B1" CR_TAB
<                        "out %i0+2,%C1" CR_TAB
<                        "out %i0+3,%D1");
<         }
<       else
<         {
<           *l = AVR_TINY ? 4 : 8;
<           return ("sts %m0,%A1"   CR_TAB
<                   "sts %m0+1,%B1" CR_TAB
<                   "sts %m0+2,%C1" CR_TAB
<                   "sts %m0+3,%D1");
<         }
<     }
< 
---
>     return *l=8,("sts %m0,%A1" CR_TAB
>                  "sts %m0+1,%B1" CR_TAB
>                  "sts %m0+2,%C1" CR_TAB
>                  "sts %m0+3,%D1");
4026,4028d3578
<       if (AVR_TINY)
<         return avr_out_movsi_mr_r_reg_no_disp_tiny (insn, op, l);
< 
4085,4088d3634
< 
<       if (AVR_TINY)
<         return avr_out_movsi_mr_r_reg_disp_tiny (op, l);
< 
4249,4315d3794
< avr_out_load_psi_reg_no_disp_tiny (rtx insn, rtx *op, int *plen)
< {
<   rtx dest = op[0];
<   rtx src = op[1];
<   rtx base = XEXP (src, 0);
<   int reg_dest = true_regnum (dest);
<   int reg_base = true_regnum (base);
< 
<   if (reg_base == reg_dest)
<     {
<       return avr_asm_len (TINY_ADIW (%E1, %F1, 2)   CR_TAB
<                           "ld %C0,%1"               CR_TAB
<                           "ld __tmp_reg__,-%1"     CR_TAB
<                           TINY_SBIW (%E1, %F1, 1)   CR_TAB
<                           "ld %A0,%1"              CR_TAB
<                           "mov %B0,__tmp_reg__", op, plen, -8);
<     }
<   else
<     {
<       return avr_asm_len ("ld %A0,%1+"  CR_TAB
<                           "ld %B0,%1+"  CR_TAB
<                           "ld %C0,%1", op, plen, -3);
< 
<       if (reg_dest != reg_base - 2 &&
<           !reg_unused_after (insn, base))
<         {
<           avr_asm_len (TINY_SBIW (%E1, %F1, 2), op, plen, 2);
<         }
<       return "";
<     }
< }
< 
< static const char*
< avr_out_load_psi_reg_disp_tiny (rtx insn, rtx *op, int *plen)
< {
<   rtx dest = op[0];
<   rtx src = op[1];
<   rtx base = XEXP (src, 0);
<   int reg_dest = true_regnum (dest);
<   int reg_base = true_regnum (base);
< 
<   reg_base = true_regnum (XEXP (base, 0));
<   if (reg_base == reg_dest)
<     {
<       return avr_asm_len (TINY_ADIW (%I1, %J1, %o1+2) CR_TAB
<                           "ld %C0,%b1"                CR_TAB
<                           "ld __tmp_reg__,-%b1"       CR_TAB
<                           TINY_SBIW (%I1, %J1, 1)     CR_TAB
<                           "ld %A0,%b1"                CR_TAB
<                           "mov %B0,__tmp_reg__", op, plen, -8);
<    }
<   else
<     {
<       avr_asm_len (TINY_ADIW (%I1, %J1, %o1)   CR_TAB
<                           "ld %A0,%b1+"              CR_TAB
<                           "ld %B0,%b1+"              CR_TAB  
<                           "ld %C0,%b1", op, plen, -5);
< 
<       if (reg_dest != (reg_base - 2)
<           && !reg_unused_after (insn, XEXP (base, 0)))
<           avr_asm_len (TINY_SBIW (%I1, %J1, %o1+2), op, plen, 2);
<       
<       return "";
<     }
< }
< 
< static const char*
4326,4328d3804
<       if (AVR_TINY)
<         return avr_out_load_psi_reg_no_disp_tiny (insn, op, plen);
< 
4371,4373d3846
<       if (AVR_TINY)
<         return avr_out_load_psi_reg_disp_tiny (insn, op, plen);
< 
4442,4447c3915,3917
<     {
<       int n_words = AVR_TINY ? 3 : 6;
<       return avr_asm_len ("lds %A0,%m1" CR_TAB
<                           "lds %B0,%m1+1" CR_TAB
<                           "lds %C0,%m1+2", op, plen , -n_words);
<     }
---
>     return avr_asm_len ("lds %A0,%m1" CR_TAB
>                         "lds %B0,%m1+1" CR_TAB
>                         "lds %C0,%m1+2", op, plen , -6);
4453,4529d3922
< 
< static const char*
< avr_out_store_psi_reg_no_disp_tiny (rtx insn, rtx *op, int *plen)
< {
<   rtx dest = op[0];
<   rtx src = op[1];
<   rtx base = XEXP (dest, 0);
<   int reg_base = true_regnum (base);
<   int reg_src = true_regnum (src);
< 
<   if (reg_base == reg_src)
<     {
<       avr_asm_len ("st %0,%A1"              CR_TAB
<                    "mov __tmp_reg__,%B1"    CR_TAB
<                    TINY_ADIW (%E0, %F0, 1)  CR_TAB /* st X+, r27 is undefined */
<                    "st %0+,__tmp_reg__"     CR_TAB
<                    "st %0,%C1", op, plen, -6);
< 
<     }
<   else if (reg_src == reg_base - 2)
<     {
<       avr_asm_len ("st %0,%A1"              CR_TAB
<                    "mov __tmp_reg__,%C1"    CR_TAB
<                    TINY_ADIW (%E0, %F0, 1)  CR_TAB
<                    "st %0+,%B1"             CR_TAB
<                    "st %0,__tmp_reg__", op, plen, 6);
<     }
<   else
<     {
<       avr_asm_len ("st %0+,%A1"  CR_TAB
<                    "st %0+,%B1" CR_TAB
<                    "st %0,%C1", op, plen, -3);
<     }
< 
<   if (!reg_unused_after (insn, base))
<     avr_asm_len (TINY_SBIW (%E0, %F0, 2), op, plen, 2);
< 
<   return "";
< }
< 
< static const char*
< avr_out_store_psi_reg_disp_tiny (rtx *op, int *plen)
< {
<   rtx dest = op[0];
<   rtx src = op[1];
<   rtx base = XEXP (dest, 0);
<   int reg_base = REGNO (XEXP (base, 0));
<   int reg_src = true_regnum (src);
< 
<   if (reg_src == reg_base)
<     {
<       return avr_asm_len ("mov __tmp_reg__,%A1"          CR_TAB
<                           "mov __zero_reg__,%B1"         CR_TAB
<                           TINY_ADIW (%I0, %J0, %o0)      CR_TAB
<                           "st %b0+,__tmp_reg__"          CR_TAB
<                           "st %b0+,__zero_reg__"         CR_TAB
<                           "st %b0,%C1"                   CR_TAB
<                           "clr __zero_reg__"             CR_TAB
<                           TINY_SBIW (%I0, %J0, %o0+2), op, plen, -10);
<     }
<   else if (reg_src == reg_base - 2)
<     {
<       return avr_asm_len ("mov __tmp_reg__,%C1"          CR_TAB  
<                           TINY_ADIW (%I0, %J0, %o0)      CR_TAB
<                           "st %b0+,%A1"                  CR_TAB
<                           "st %b0+,%B1"                  CR_TAB
<                           "st %b0,__tmp_reg__"           CR_TAB
<                           TINY_SBIW (%I0, %J0, %o0+2), op, plen, -8);
<     }
< 
<   return avr_asm_len (TINY_ADIW (%I0, %J0, %o0)      CR_TAB
<                           "st %b0+,%A1"                  CR_TAB
<                           "st %b0+,%B1"                  CR_TAB
<                           "st %b0,%C1"                   CR_TAB
<                           TINY_SBIW (%I0, %J0, %o0+2), op, plen, -7);
< }
< 
4541,4546c3934,3936
<     {
<       int n_words = AVR_TINY ? 3 : 6;
<       return avr_asm_len ("sts %m0,%A1"   CR_TAB
<                           "sts %m0+1,%B1" CR_TAB
<                           "sts %m0+2,%C1", op, plen, -n_words);
<     }
---
>     return avr_asm_len ("sts %m0,%A1"   CR_TAB
>                         "sts %m0+1,%B1" CR_TAB
>                         "sts %m0+2,%C1", op, plen, -6);
4550,4552d3939
<       if (AVR_TINY)
<         return avr_out_store_psi_reg_no_disp_tiny (insn, op, plen);
< 
4574,4577d3960
< 
<       if (AVR_TINY)
<         return avr_out_store_psi_reg_disp_tiny (op, plen);
< 
4590c3973
<                                 "sbiw r28,%o0-61", op, plen, -5);
---
>                                 "sbiw r28,%o0-60", op, plen, -5);
4694,4717d4076
< static const char*
< avr_out_movqi_mr_r_reg_disp_tiny (rtx insn, rtx op[], int *plen)
< {
<   rtx dest = op[0];
<   rtx src = op[1];
<   rtx x = XEXP (dest, 0);
< 
<   if (reg_overlap_mentioned_p (src, XEXP (x, 0)))
<     {
<       avr_asm_len ("mov __tmp_reg__,%1"      CR_TAB
<                    TINY_ADIW (%I0, %J0, %o0) CR_TAB
<                    "st %b0,__tmp_reg__", op, plen, -4);
<     }
<     else
<     {
<       avr_asm_len (TINY_ADIW (%I0, %J0, %o0) CR_TAB
<           "st %b0,%1" , op, plen, -3);
<     }
< 
<   if (!reg_unused_after (insn, XEXP (x,0)))
<       avr_asm_len (TINY_SBIW (%I0, %J0, %o0), op, plen, 2);
< 
<   return "";
< }
4728d4086
<       int n_words = AVR_TINY ? 1 : 2;
4731c4089
<         : avr_asm_len ("sts %m0,%1", op, plen, -n_words);
---
>         : avr_asm_len ("sts %m0,%1", op, plen, -2);
4741,4743d4098
<       if (AVR_TINY)
<         return avr_out_movqi_mr_r_reg_disp_tiny (insn, op, plen);
< 
4804,4808c4159,4161
<     {
<       int n_words = AVR_TINY ? 2 : 4;
<       return optimize > 0 && io_address_operand (base, HImode)
<         ? avr_asm_len ("out %i0,%A1" CR_TAB
<                        "out %i0+1,%B1", op, plen, -2)
---
>     return optimize > 0 && io_address_operand (base, HImode)
>       ? avr_asm_len ("out %i0,%A1" CR_TAB
>                      "out %i0+1,%B1", op, plen, -2)
4810,4812c4163,4164
<         : avr_asm_len ("sts %m0,%A1" CR_TAB
<                        "sts %m0+1,%B1", op, plen, -n_words);
<     }
---
>       : avr_asm_len ("sts %m0,%A1" CR_TAB
>                      "sts %m0+1,%B1", op, plen, -4);
4901,4966d4252
< static const char*
< avr_out_movhi_mr_r_reg_no_disp_tiny (rtx insn, rtx op[], int *plen)
< {
<   rtx dest = op[0];
<   rtx src = op[1];
<   rtx base = XEXP (dest, 0);
<   int reg_base = true_regnum (base);
<   int reg_src = true_regnum (src);
<   int mem_volatile_p = MEM_VOLATILE_P (dest);
< 
<   if (reg_base == reg_src)
<     {
<       return !mem_volatile_p && reg_unused_after (insn, src)
<         ? avr_asm_len ("mov __tmp_reg__,%B1"   CR_TAB
<                        "st %0,%A1"             CR_TAB
<                        TINY_ADIW (%E0, %F0, 1) CR_TAB
<                        "st %0,__tmp_reg__", op, plen, -5)
<         : avr_asm_len ("mov __tmp_reg__,%B1"   CR_TAB
<                        TINY_ADIW (%E0, %F0, 1) CR_TAB
<                        "st %0,__tmp_reg__"      CR_TAB
<                        TINY_SBIW (%E0, %F0, 1) CR_TAB
<                        "st %0, %A1", op, plen, -7);
<     }
< 
<   return !mem_volatile_p && reg_unused_after (insn, base)
<       ? avr_asm_len ("st %0+,%A1" CR_TAB
<                      "st %0,%B1", op, plen, -2)
<       : avr_asm_len (TINY_ADIW (%E0, %F0, 1) CR_TAB
<                      "st %0,%B1"             CR_TAB
<                      "st -%0,%A1", op, plen, -4);
< }
< 
< static const char*
< avr_out_movhi_mr_r_reg_disp_tiny (rtx op[], int *plen)
< {
<   rtx dest = op[0];
<   rtx src = op[1];
<   rtx base = XEXP (dest, 0);
<   int reg_base = REGNO (XEXP (base, 0));
<   int reg_src = true_regnum (src);
< 
<   return reg_src == reg_base
<         ? avr_asm_len ("mov __tmp_reg__,%A1"          CR_TAB
<                        "mov __zero_reg__,%B1"         CR_TAB
<                        TINY_ADIW (%I0, %J0, %o0+1)    CR_TAB
<                        "st %b0,__zero_reg__"          CR_TAB
<                        "st -%b0,__tmp_reg__"          CR_TAB
<                        "clr __zero_reg__"             CR_TAB
<                        TINY_SBIW (%I0, %J0, %o0), op, plen, -9) 
< 
<         : avr_asm_len (TINY_ADIW (%I0, %J0, %o0+1) CR_TAB
<                        "st %b0,%B1"                CR_TAB
<                        "st -%b0,%A1"               CR_TAB
<                        TINY_SBIW (%I0, %J0, %o0), op, plen, -6);
< }
< 
< static const char*
< avr_out_movhi_mr_r_post_inc_tiny (rtx op[], int *plen)
< {
<   rtx dest = op[0];
< 
<   return avr_asm_len (TINY_ADIW (%I0, %J0, 1)  CR_TAB
<                       "st %p0,%B1"    CR_TAB
<                       "st -%p0,%A1"   CR_TAB
<                       TINY_ADIW (%I0, %J0, 2), op, plen, -6);
< }
4988,4992c4274,4276
<     {
<       int n_words = AVR_TINY ? 2 : 4;
<       return optimize > 0 && io_address_operand (base, HImode)
<         ? avr_asm_len ("out %i0+1,%B1" CR_TAB
<                        "out %i0,%A1", op, plen, -2)
---
>     return optimize > 0 && io_address_operand (base, HImode)
>       ? avr_asm_len ("out %i0+1,%B1" CR_TAB
>                      "out %i0,%A1", op, plen, -2)
4994,4996c4278,4279
<         : avr_asm_len ("sts %m0+1,%B1" CR_TAB
<                        "sts %m0,%A1", op, plen, -n_words);
<     }
---
>       : avr_asm_len ("sts %m0+1,%B1" CR_TAB
>                      "sts %m0,%A1", op, plen, -4);
5000,5002d4282
<       if (AVR_TINY)
<         return avr_out_movhi_mr_r_reg_no_disp_tiny (insn, op, plen);
< 
5031,5034d4310
< 
<       if (AVR_TINY)
<         return avr_out_movhi_mr_r_reg_disp_tiny (op, plen);
< 
5084,5086d4359
<       if (AVR_TINY)
<         return avr_out_movhi_mr_r_post_inc_tiny (op, plen);
< 
5269,5273c4542
<               if (AVR_TINY)
<                 avr_asm_len (TINY_SBIW (%A0, %B0, %1), xop, plen, 2);
<               else
<                 avr_asm_len ("sbiw %0,%1", xop, plen, 1);
< 
---
>               avr_asm_len ("sbiw %0,%1", xop, plen, 1);
5283,5285c4552
<               return AVR_TINY
<                   ? avr_asm_len (TINY_ADIW (%A0, %B0, %n1), xop, plen, 2)
<                   : avr_asm_len ("adiw %0,%n1", xop, plen, 1);
---
>               return avr_asm_len ("adiw %0,%n1", xop, plen, 1);
6961,6964c6228
<    If OUT_LABEL is true, print the final 0: label which is needed for
<    saturated addition / subtraction.  The only case where OUT_LABEL = false
<    is useful is for saturated addition / subtraction performed during
<    fixed-point rounding, cf. `avr_out_round'.  */
---
>    Return "".  */
6968c6232
<                 enum rtx_code code_sat, int sign, bool out_label)
---
>                 enum rtx_code code_sat = UNKNOWN, int sign = 0)
7407,7408c6671
<   if (out_label)
<     avr_asm_len ("0:", op, plen, 0);
---
>   avr_asm_len ("0:", op, plen, 0);
7446,7447c6709,6710
<    INSN is a single_set insn or an insn pattern with a binary operation as
<    SET_SRC that is one of: PLUS, SS_PLUS, US_PLUS, MINUS, SS_MINUS, US_MINUS.
---
>    INSN is a single_set insn with a binary operation as SET_SRC that is
>    one of:  PLUS, SS_PLUS, US_PLUS, MINUS, SS_MINUS, US_MINUS.
7462,7463d6724
<    OUT_LABEL defaults to TRUE.  For a description, see AVR_OUT_PLUS_1.
< 
7467c6728
< avr_out_plus (rtx insn, rtx *xop, int *plen, int *pcc, bool out_label)
---
> avr_out_plus (rtx insn, rtx *xop, int *plen, int *pcc)
7472,7473c6733
<   rtx xpattern = INSN_P (insn) ? single_set (insn) : insn;
<   rtx xdest = SET_DEST (xpattern);
---
>   rtx xdest = SET_DEST (single_set (insn));
7477c6737
<   enum rtx_code code_sat = GET_CODE (SET_SRC (xpattern));
---
>   enum rtx_code code_sat = GET_CODE (SET_SRC (single_set (insn)));
7492c6752
<       avr_out_plus_1 (xop, plen, code, pcc, code_sat, 0, out_label);
---
>       avr_out_plus_1 (xop, plen, code, pcc, code_sat);
7519,7520c6779
<   xpattern = INSN_P (insn) ? PATTERN (insn) : insn;
<   op[3] = PARALLEL == GET_CODE (xpattern) ? xop[3] : NULL_RTX;
---
>   op[3] = PARALLEL == GET_CODE (PATTERN (insn)) ? xop[3] : NULL_RTX;
7535,7536c6794,6795
<   avr_out_plus_1 (op, &len_minus, MINUS, &cc_plus, code_sat, sign, out_label);
<   avr_out_plus_1 (op, &len_plus, PLUS, &cc_minus, code_sat, sign, out_label);
---
>   avr_out_plus_1 (op, &len_minus, MINUS, &cc_plus, code_sat, sign);
>   avr_out_plus_1 (op, &len_plus, PLUS, &cc_minus, code_sat, sign);
7544c6803
<     avr_out_plus_1 (op, NULL, MINUS, pcc, code_sat, sign, out_label);
---
>     avr_out_plus_1 (op, NULL, MINUS, pcc, code_sat, sign);
7546c6805
<     avr_out_plus_1 (op, NULL, PLUS, pcc, code_sat, sign, out_label);
---
>     avr_out_plus_1 (op, NULL, PLUS, pcc, code_sat, sign);
7560,7561c6819
<    register or SCRATCH if no clobber register is needed for the operation.
<    INSN is an INSN_P or a pattern of an insn.  */
---
>    register or SCRATCH if no clobber register is needed for the operation.  */
7567,7568c6825
<   rtx xpattern = INSN_P (insn) ? single_set (insn) : insn;
<   enum rtx_code code = GET_CODE (SET_SRC (xpattern));
---
>   enum rtx_code code = GET_CODE (SET_SRC (single_set (insn)));
7763d7019
<   bool lsb_in_tmp_reg = false;
7765d7020
<   bool frac_rounded = false;
7773d7027
<    || (offset && IN_RANGE (RR, dest.regno, dest.regno_msb))		\
7848,7953d7101
<   /* If we need to round the fraction part, we might need to save/round it
<      before clobbering any of it in Step 1.  Also, we might to want to do
<      the rounding now to make use of LD_REGS.  */
<   if (SCALAR_INT_MODE_P (GET_MODE (xop[0]))
<       && SCALAR_ACCUM_MODE_P (GET_MODE (xop[1]))
<       && !TARGET_FRACT_CONV_TRUNC)
<     {
<       bool overlap
< 	= (src.regno <=
< 	   (offset ? dest.regno_msb - sign_bytes : dest.regno + zero_bytes - 1)
< 	   && dest.regno - offset -1 >= dest.regno);
<       unsigned s0 = dest.regno - offset -1;
<       bool use_src = true;
<       unsigned sn;
<       unsigned copied_msb = src.regno_msb;
<       bool have_carry = false;
< 
<       if (src.ibyte > dest.ibyte)
< 	copied_msb -= src.ibyte - dest.ibyte;
< 
<       for (sn = s0; sn <= copied_msb; sn++)
< 	if (!IN_RANGE (sn, dest.regno, dest.regno_msb)
< 	    && !reg_unused_after (insn, all_regs_rtx[sn]))
< 	  use_src = false;
<       if (use_src && TEST_HARD_REG_BIT (reg_class_contents[LD_REGS], s0))
< 	{
< 	  avr_asm_len ("tst %0" CR_TAB "brpl 0f",
< 		       &all_regs_rtx[src.regno_msb], plen, 2);
< 	  sn = src.regno;
< 	  if (sn < s0)
< 	    {
< 	      if (TEST_HARD_REG_BIT (reg_class_contents[LD_REGS], sn))
< 		avr_asm_len ("cpi %0,1", &all_regs_rtx[sn], plen, 1);
< 	      else
< 		avr_asm_len ("sec" CR_TAB "cpc %0,__zero_reg__",
< 			     &all_regs_rtx[sn], plen, 2);
< 	      have_carry = true;
< 	    }
< 	  while (++sn < s0)
< 	    avr_asm_len ("cpc %0,__zero_reg__", &all_regs_rtx[sn], plen, 1);
< 	  avr_asm_len (have_carry ? "sbci %0,128" : "subi %0,129",
< 		       &all_regs_rtx[s0], plen, 1);
< 	  for (sn = src.regno + src.fbyte; sn <= copied_msb; sn++)
< 	    avr_asm_len ("sbci %0,255", &all_regs_rtx[sn], plen, 1);
< 	  avr_asm_len ("\n0:", NULL, plen, 0);
< 	  frac_rounded = true;
< 	}
<       else if (use_src && overlap)
< 	{
< 	  avr_asm_len ("clr __tmp_reg__" CR_TAB
< 		       "sbrc %1,0" CR_TAB "dec __tmp_reg__", xop, plen, 1);
< 	  sn = src.regno;
< 	  if (sn < s0)
< 	    {
< 	      avr_asm_len ("add %0,__tmp_reg__", &all_regs_rtx[sn], plen, 1);
< 	      have_carry = true;
< 	    }
< 	  while (++sn < s0)
< 	    avr_asm_len ("adc %0,__tmp_reg__", &all_regs_rtx[sn], plen, 1);
< 	  if (have_carry)
< 	    avr_asm_len ("clt" CR_TAB "bld __tmp_reg__,7" CR_TAB
< 			 "adc %0,__tmp_reg__",
< 			 &all_regs_rtx[s0], plen, 1);
< 	  else
< 	    avr_asm_len ("lsr __tmp_reg" CR_TAB "add %0,__tmp_reg__",
< 			 &all_regs_rtx[s0], plen, 2);
< 	  for (sn = src.regno + src.fbyte; sn <= copied_msb; sn++)
< 	    avr_asm_len ("adc %0,__zero_reg__", &all_regs_rtx[sn], plen, 1);
< 	  frac_rounded = true;
< 	}
<       else if (overlap)
< 	{
< 	  bool use_src
< 	    = (TEST_HARD_REG_BIT (reg_class_contents[LD_REGS], s0)
< 	       && (IN_RANGE (s0, dest.regno, dest.regno_msb)
< 		   || reg_unused_after (insn, all_regs_rtx[s0])));
< 	  xop[2] = all_regs_rtx[s0];
< 	  unsigned sn = src.regno;
< 	  if (!use_src || sn == s0)
< 	    avr_asm_len ("mov __tmp_reg__,%2", xop, plen, 1);
< 	  /* We need to consider to-be-discarded bits
< 	     if the value is negative.  */
< 	  if (sn < s0)
< 	    {
< 	      avr_asm_len ("tst %0" CR_TAB "brpl 0f",
< 			   &all_regs_rtx[src.regno_msb], plen, 2);
< 	      /* Test to-be-discarded bytes for any nozero bits.
< 		 ??? Could use OR or SBIW to test two registers at once.  */
< 	      if (sn < s0)
< 		avr_asm_len ("cp %0,__zero_reg__", &all_regs_rtx[sn], plen, 1);
< 	      while (++sn < s0)
< 		avr_asm_len ("cpc %0,__zero_reg__", &all_regs_rtx[sn], plen, 1);
< 	      /* Set bit 0 in __tmp_reg__ if any of the lower bits was set.  */
< 	      if (use_src)
< 		avr_asm_len ("breq 0f" CR_TAB
< 			     "ori %2,1" "\n0:\t" "mov __tmp_reg__,%2",
< 			     xop, plen, 3);
< 	      else
< 		avr_asm_len ("breq 0f" CR_TAB
< 			     "set" CR_TAB "bld __tmp_reg__,0\n0:",
< 			     xop, plen, 3);
< 	    }
< 	  lsb_in_tmp_reg = true;
< 	}
<     }
< 
7960c7108
<   // We cleared at least that number of registers.
---
>   // We leared at least that number of registers.
8050d7197
< 	      && !lsb_in_tmp_reg
8072,8156c7219
<       /* n1169 4.1.4 says:
< 	 "Conversions from a fixed-point to an integer type round toward zero."
< 	 Hence, converting a fract type to integer only gives a non-zero result
< 	 for -1.  */
<       if (SCALAR_INT_MODE_P (GET_MODE (xop[0]))
< 	  && SCALAR_FRACT_MODE_P (GET_MODE (xop[1]))
< 	  && !TARGET_FRACT_CONV_TRUNC)
< 	{
< 	  gcc_assert (s0 == src.regno_msb);
< 	  /* Check if the input is -1.  We do that by checking if negating
< 	     the input causes an integer overflow.  */
< 	  unsigned sn = src.regno;
< 	  avr_asm_len ("cp __zero_reg__,%0", &all_regs_rtx[sn++], plen, 1);
< 	  while (sn <= s0)
< 	    avr_asm_len ("cpc __zero_reg__,%0", &all_regs_rtx[sn++], plen, 1);
< 
< 	  /* Overflow goes with set carry.  Clear carry otherwise.  */
< 	  avr_asm_len ("brvs 0f" CR_TAB "clc\n0:", NULL, plen, 2);
< 	}
<       /* Likewise, when converting from accumulator types to integer, we
< 	 need to round up negative values.  */
<       else if (SCALAR_INT_MODE_P (GET_MODE (xop[0]))
< 	       && SCALAR_ACCUM_MODE_P (GET_MODE (xop[1]))
< 	       && !TARGET_FRACT_CONV_TRUNC
< 	       && !frac_rounded)
< 	{
< 	  bool have_carry = false;
< 
< 	  xop[2] = all_regs_rtx[s0];
< 	  if (!lsb_in_tmp_reg && !MAY_CLOBBER (s0))
< 	    avr_asm_len ("mov __tmp_reg__,%2", xop, plen, 1);
< 	  avr_asm_len ("tst %0" CR_TAB "brpl 0f",
< 		       &all_regs_rtx[src.regno_msb], plen, 2);
< 	  if (!lsb_in_tmp_reg)
< 	    {
< 	      unsigned sn = src.regno;
< 	      if (sn < s0)
< 		{
< 		  avr_asm_len ("cp __zero_reg__,%0", &all_regs_rtx[sn],
< 			       plen, 1);
< 		  have_carry = true;
< 		}
< 	      while (++sn < s0)
< 		avr_asm_len ("cpc __zero_reg__,%0", &all_regs_rtx[sn], plen, 1);
< 	      lsb_in_tmp_reg = !MAY_CLOBBER (s0);
< 	    }
< 	  /* Add in C and the rounding value 127.  */
< 	  /* If the destination msb is a sign byte, and in LD_REGS,
< 	     grab it as a temporary.  */
< 	  if (sign_bytes
< 	      && TEST_HARD_REG_BIT (reg_class_contents[LD_REGS],
< 				    dest.regno_msb))
< 	    {
< 	      xop[3] = all_regs_rtx[dest.regno_msb];
< 	      avr_asm_len ("ldi %3,127", xop, plen, 1);
< 	      avr_asm_len ((have_carry && lsb_in_tmp_reg ? "adc __tmp_reg__,%3"
< 			   : have_carry ? "adc %2,%3"
< 			   : lsb_in_tmp_reg ? "add __tmp_reg__,%3"
< 			   : "add %2,%3"),
< 			   xop, plen, 1);
< 	    }
< 	  else
< 	    {
< 	      /* Fall back to use __zero_reg__ as a temporary.  */
< 	      avr_asm_len ("dec __zero_reg__", NULL, plen, 1);
< 	      if (have_carry)
< 		avr_asm_len ("clt" CR_TAB "bld __zero_reg__,7", NULL, plen, 2);
< 	      else
< 		avr_asm_len ("lsr __zero_reg__", NULL, plen, 1);
< 	      avr_asm_len ((have_carry && lsb_in_tmp_reg
< 			   ? "adc __tmp_reg__,__zero_reg__"
< 			   : have_carry ? "adc %2,__zero_reg__"
< 			   : lsb_in_tmp_reg ? "add __tmp_reg__,__zero_reg__"
< 			   : "add %2,__zero_reg__"),
< 			   xop, plen, 1);
< 	      avr_asm_len ("eor __zero_reg__,__zero_reg__", NULL, plen, 1);
< 	    }
< 	  for (d0 = dest.regno + zero_bytes;
< 	       d0 <= dest.regno_msb - sign_bytes; d0++)
< 	    avr_asm_len ("adc %0,__zero_reg__", &all_regs_rtx[d0], plen, 1);
< 	  avr_asm_len (lsb_in_tmp_reg
< 		       ? "\n0:\t" "lsl __tmp_reg__" : "\n0:\t" "lsl %2",
< 		       xop, plen, 1);
< 	}
<       else if (MAY_CLOBBER (s0))
---
>       if (MAY_CLOBBER (s0))
8265,8325d7327
< /* Output fixed-point rounding.  XOP[0] = XOP[1] is the operand to round.
<    XOP[2] is the rounding point, a CONST_INT.  The function prints the
<    instruction sequence if PLEN = NULL and computes the length in words
<    of the sequence if PLEN != NULL.  Most of this function deals with
<    preparing operands for calls to `avr_out_plus' and `avr_out_bitop'.  */
< 
< const char*
< avr_out_round (rtx insn ATTRIBUTE_UNUSED, rtx *xop, int *plen)
< {
<   enum machine_mode mode = GET_MODE (xop[0]);
<   enum machine_mode imode = int_mode_for_mode (mode);
<   // The smallest fractional bit not cleared by the rounding is 2^(-RP).
<   int fbit = (int) GET_MODE_FBIT (mode);
<   double_int i_add = double_int_zero.set_bit (fbit-1 - INTVAL (xop[2]));
<   // Lengths of PLUS and AND parts.
<   int len_add = 0, *plen_add = plen ? &len_add : NULL;
<   int len_and = 0, *plen_and = plen ? &len_and : NULL;
< 
<   // Add-Saturate  1/2 * 2^(-RP).  Don't print the label "0:" when printing
<   // the saturated addition so that we can emit the "rjmp 1f" before the
<   // "0:" below.
< 
<   rtx xadd = const_fixed_from_double_int (i_add, mode);
<   rtx xpattern, xsrc, op[4];
< 
<   xsrc = SIGNED_FIXED_POINT_MODE_P (mode)
<     ? gen_rtx_SS_PLUS (mode, xop[1], xadd)
<     : gen_rtx_US_PLUS (mode, xop[1], xadd);
<   xpattern = gen_rtx_SET (VOIDmode, xop[0], xsrc);
< 
<   op[0] = xop[0];
<   op[1] = xop[1];
<   op[2] = xadd;
<   avr_out_plus (xpattern, op, plen_add, NULL, false /* Don't print "0:" */);
< 
<   avr_asm_len ("rjmp 1f" CR_TAB
<                "0:", NULL, plen_add, 1);
< 
<   // Keep  all bits from RP and higher:   ... 2^(-RP)
<   // Clear all bits from RP+1 and lower:              2^(-RP-1) ...
<   // Rounding point                           ^^^^^^^
<   // Added above                                      ^^^^^^^^^
<   rtx xreg = simplify_gen_subreg (imode, xop[0], mode, 0);
<   rtx xmask = immed_double_int_const (-i_add - i_add, imode);
< 
<   xpattern = gen_rtx_SET (VOIDmode, xreg, gen_rtx_AND (imode, xreg, xmask));
< 
<   op[0] = xreg;
<   op[1] = xreg;
<   op[2] = xmask;
<   op[3] = gen_rtx_SCRATCH (QImode);
<   avr_out_bitop (xpattern, op, plen_and);
<   avr_asm_len ("1:", NULL, plen, 0);
< 
<   if (plen)
<     *plen = len_add + len_and;
< 
<   return "";
< }
< 
< 
8534d7535
<     case ADJUST_LEN_ROUND: avr_out_round (insn, op, &len); break;
8745,8746c7746
<   return (c != ALL_REGS &&
<            (AVR_TINY ? 1 : c != ADDW_REGS));
---
>   return (c != ALL_REGS && c != ADDW_REGS);
8846,8847d7845
<   { "nmi",       0, 0, true,  false, false,  avr_handle_fndecl_attribute,
<     false },
9329,9332c8327
<       tree type = TREE_TYPE (decl);
<       if (type == error_mark_node)
< 	return;
<       addr_space_t as = TYPE_ADDR_SPACE (type);
---
>       addr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (decl));
9418c8413
<   if (AVR_XMEGA || AVR_TINY)
---
>   if (AVR_XMEGA)
9420,9421c8415,8416
<   fprintf (asm_out_file, "__tmp_reg__ = %d\n", AVR_TMP_REGNO);
<   fprintf (asm_out_file, "__zero_reg__ = %d\n", AVR_ZERO_REGNO);
---
>   fprintf (asm_out_file, "__tmp_reg__ = %d\n", TMP_REGNO);
>   fprintf (asm_out_file, "__zero_reg__ = %d\n", ZERO_REGNO);
9468,9479d8462
<   static const int tiny_order_0[] = {
<     20, 21,
<     22, 23,
<     24, 25,
<     30, 31,
<     26, 27,
<     28, 29,
<     19, 18,
<     16, 17,
<     32, 33, 34, 35,
<     15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0
<   };
9489,9499d8471
<   static const int tiny_order_1[] = {
<     22, 23,
<     24, 25,
<     30, 31,
<     26, 27,
<     28, 29,
<     21, 20, 19, 18,
<     16, 17,
<     32, 33, 34, 35,
<     15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0
<   };
9510,9517c8482,8484
<   /*
<   Select specific register allocation order. Tiny Core (attiny4/5/9/10/20/40)
<   devices has only 16 registers, so different allocation order should be used
<   */ 
<   const int *order = (TARGET_ORDER_1 ? (AVR_TINY ? tiny_order_1 : order_1) :
<              TARGET_ORDER_2 ? (AVR_TINY ? tiny_order_0 : order_2) :
<                                        (AVR_TINY ? tiny_order_0 : order_0));
< 
---
>   const int *order = (TARGET_ORDER_1 ? order_1 :
> 		      TARGET_ORDER_2 ? order_2 :
> 		      order_0);
10870c9837
<   if ((avr_current_device->dev_attribute & AVR_ERRATA_SKIP)
---
>   if (avr_current_device->errata_skip
11199c10166
<                          : AVR_ZERO_REGNO == REGNO (xdest[n]) ? "clr %0"
---
>                          : ZERO_REGNO == REGNO (xdest[n]) ? "clr %0"
11401,11443d10367
< static void
< avr_conditional_register_usage(void) {
< 
<   if (AVR_TINY) {
<     unsigned int i;
< 
<     const int tiny_reg_alloc_order[] = {
<       24, 25,
<       22, 23,
<       30, 31,
<       26, 27,
<       28, 29,
<       21, 20, 19, 18,
<       16, 17,
<       32, 33, 34, 35,
<       15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0
<     };
< 
<     /* Set R0-R17 as fixed registers. Reset R0-R17 in call used register list
<     - R0-R15 are not available in Tiny Core devices
<     - R16 and R17 are fixed registers
<     */
<     for (i = 0;  i <= 17;  i++) {
<       fixed_regs[i] = 1;
<       call_used_regs[i] = 1;
<     }
< 
<     /* Set R18 to R21 as callee saved registers
<     - R18, R19, R20 and R21 are the callee saved registers in Tiny Core devices
<     */
<     for (i = 18; i <= LAST_CALLEE_SAVED_REG; i++) {
<       call_used_regs[i] = 0;
<     }
< 
<     /*update register allocation order for Tiny Core devices */
<     for (i=0; i < ARRAY_SIZE (tiny_reg_alloc_order); i++) {
<       reg_alloc_order[i] = tiny_reg_alloc_order[i];
<     }
< 
<     CLEAR_HARD_REG_SET(reg_class_contents[(int)ADDW_REGS]);
<     CLEAR_HARD_REG_SET(reg_class_contents[(int)NO_LD_REGS]);
<   }
< }
11595,11604c10519,10523
<   HOST_WIDE_INT size = int_size_in_bytes (type);
<   HOST_WIDE_INT ret_size_limit = AVR_TINY ? 4 : 8;                                      
< 
<   /* In avr, there are 8 return registers. But, for Tiny Core 
<   (attiny4/5/9/10/20/40) devices, only 4 registers available.
<   Return true if size is unknown or greater than the limit */
<   if ((size == -1) || (size > ret_size_limit))
<   {
<     return true;
<   }
---
>   if (TYPE_MODE (type) == BLKmode)
>     {
>       HOST_WIDE_INT size = int_size_in_bytes (type);
>       return (size == -1 || size > 8);
>     }
11606d10524
<   {
11608d10525
<   }
13242,13244d12158
< 
< #undef TARGET_CONDITIONAL_REGISTER_USAGE
< #define TARGET_CONDITIONAL_REGISTER_USAGE avr_conditional_register_usage
diff -r avr/gcc/config/avr/avr.h gcc/gcc/config/avr/avr.h
91,93c91,92
< #define AVR_HAVE_8BIT_SP                                 \
<   ((avr_current_device->dev_attribute & AVR_SHORT_SP) || \
<    TARGET_TINY_STACK || avr_sp8)
---
> #define AVR_HAVE_8BIT_SP                                                \
>   (avr_current_device->short_sp || TARGET_TINY_STACK || avr_sp8)
101d99
< #define AVR_TINY  (avr_current_arch->tiny_p)
149,150d146
< #define WCHAR_TYPE "int"
< #define WINT_TYPE "int"
310c306
< #define STATIC_CHAIN_REGNUM ((AVR_TINY) ? 18 :2)
---
> #define STATIC_CHAIN_REGNUM 2
496d491
< extern const char *avr_device_to_text_start (int argc, const char **argv);
505d499
<   { "device_to_text_start", avr_device_to_text_start }, \
519,520c513
< #define ASM_SPEC "%:device_to_as(%{mmcu=*:%*})\
< %{mrelax:-mlink-relax}"
---
> #define ASM_SPEC "%:device_to_as(%{mmcu=*:%*}) "
532,533c525
< %:device_to_data_start(%{mmcu=*:%*})\
< %:device_to_text_start(%{mmcu=*:%*})"
---
> %:device_to_data_start(%{mmcu=*:%*})"
582,585d573
< 
<   /* 'true' - if current function is an nmi function 
<      as specified by the "nmi" attribute.  */
<   int is_nmi;
diff -r avr/gcc/config/avr/avr.md gcc/gcc/config/avr/avr.md
27,30d26
< ;;  E  reg number in XEXP(x, 0).
< ;;  F  Add 1 to reg number.
< ;;  I  reg number in XEXP(XEXP(x, 0), 0).
< ;;  J  Add 1 to reg number.
39d34
< ;;  r  Print a REG without the register prefix 'r'.
66,70d60
< (define_constants
<   [ (TMP_REGNO_TINY 16)  ; r16 is temp register for AVR_TINY
<     (ZERO_REGNO_TINY 17) ; r17 is zero register for AVR_TINY
<   ])
< 
153c143
<    ufract, sfract, round,
---
>    ufract, sfract,
171d160
< ;; no_tiny:  non-TINY core               tiny  : TINY core
174c163
<   "mov,movw, rjmp,jmp, ijmp,eijmp, lpm,lpmx, elpm,elpmx, no_xmega,xmega, no_tiny,tiny,
---
>   "mov,movw, rjmp,jmp, ijmp,eijmp, lpm,lpmx, elpm,elpmx, no_xmega,xmega,
226,229d214
<          (and (eq_attr "isa" "tiny")
<               (match_test "AVR_TINY"))
<          (const_int 1)
< 
233,237d217
< 
<          (and (eq_attr "isa" "no_tiny")
<               (match_test "!AVR_TINY"))
<          (const_int 1)
< 
632,658d611
< 
<     /* AVRTC-579
<     if the source operand expression is out of range for 'lds' instruction
<       copy source operand expression to register
<     For tiny core, LDS instruction's memory access range limited to 0x40..0xbf
<     */
<     if (!tiny_valid_direct_memory_access_range(src,<MODE>mode))
<       {
<         rtx srcx = XEXP(src,0);
<         operands[1] = src = replace_equiv_address (src,copy_to_mode_reg (GET_MODE(srcx),srcx));
<         emit_move_insn(dest,src);
<         DONE;
<       }
< 
<     /* AVRTC-579
<     if the destination operand expression is out of range for 'sts' instruction
<       copy destination operand expression to register
<     For tiny core, STS instruction's memory access range limited to 0x40..0xbf
<     */
<     if (!tiny_valid_direct_memory_access_range(dest,<MODE>mode))
<     {
<       rtx destx = XEXP(dest,0);
<       operands[0] = dest = replace_equiv_address (dest,copy_to_mode_reg (GET_MODE(destx),destx));
<       emit_move_insn(dest,src);
<       DONE;
<     }
< 
675,681c628,629
<   "(register_operand (operands[0], <MODE>mode)
<    || reg_or_0_operand (operands[1], <MODE>mode)) &&
<    /* skip if operands are out of lds/sts memory access range(0x40..0xbf)
<    though access range is checked during define_expand, it is required
<    here to avoid merging rtls during combine pass */
<    tiny_valid_direct_memory_access_range(operands[0],QImode) &&
<    tiny_valid_direct_memory_access_range(operands[1],QImode)"
---
>   "register_operand (operands[0], <MODE>mode)
>    || reg_or_0_operand (operands[1], <MODE>mode)"
774,780c722,723
<   "(register_operand (operands[0], <MODE>mode)
<    || reg_or_0_operand (operands[1], <MODE>mode)) &&
<    /* skip if operands are out of lds/sts memory access range(0x40..0xbf)
<    though access range is checked during define_expand, it is required
<    here to avoid merging rtls during combine pass */
<    tiny_valid_direct_memory_access_range(operands[0],HImode) &&
<    tiny_valid_direct_memory_access_range(operands[1],HImode)"
---
>   "register_operand (operands[0], <MODE>mode)
>    || reg_or_0_operand (operands[1], <MODE>mode)"
928,934c871,872
<   "(register_operand (operands[0], <MODE>mode)
<    || reg_or_0_operand (operands[1], <MODE>mode)) &&
<    /* skip if operands are out of lds/sts memory access range(0x40..0xbf)
<    though access range is checked during define_expand, it is required
<    here to avoid merging rtls during combine pass */
<    tiny_valid_direct_memory_access_range(operands[0],SImode) &&
<    tiny_valid_direct_memory_access_range(operands[1],SImode)"
---
>   "register_operand (operands[0], <MODE>mode)
>    || reg_or_0_operand (operands[1], <MODE>mode)"
948,954c886,887
<   "(register_operand (operands[0], SFmode)
<    || reg_or_0_operand (operands[1], SFmode)) &&
<    /* skip if operands are out of lds/sts memory access range(0x40..0xbf)
<    though access range is checked during define_expand, it is required
<    here to avoid merging rtls during combine pass */
<    tiny_valid_direct_memory_access_range(operands[0],SFmode) &&
<    tiny_valid_direct_memory_access_range(operands[1],SFmode)"
---
>   "register_operand (operands[0], SFmode)
>    || reg_or_0_operand (operands[1], SFmode)"
5411c5344
<    || !(avr_current_device->dev_attribute & AVR_ERRATA_SKIP)"
---
>    || !avr_current_device->errata_skip"
5580c5513
<   [(unspec_volatile [(match_operand:HI 0 "const_int_operand" "n,n")
---
>   [(unspec_volatile [(match_operand:HI 0 "const_int_operand" "n")
5585c5518
<    (clobber (match_scratch:HI 2 "=&w,&d"))]
---
>    (clobber (match_scratch:HI 2 "=&w"))]
5587,5591c5520,5524
<   "@
<     ldi %A2,lo8(%0)\;ldi %B2,hi8(%0)\;1: sbiw %A2,1\;brne 1b
<     ldi %A2,lo8(%0)\;ldi %B2,hi8(%0)\;1: subi %A2,1\;sbci %B2,0\;brne 1b"
<   [(set_attr "length" "4,5")
<    (set_attr "isa" "no_tiny,tiny")
---
>   "ldi %A2,lo8(%0)
> 	ldi %B2,hi8(%0)
> 	1: sbiw %A2,1
> 	brne 1b"
>   [(set_attr "length" "4")
diff -r avr/gcc/config/avr/avr.opt gcc/gcc/config/avr/avr.opt
80,84c80
< Warn if the address space of an address is changed.
< 
< mfract-convert-truncate
< Target Report Mask(FRACT_CONV_TRUNC)
< Allow to use truncation instead of rounding towards 0 for fractional int types
---
> Warn if the address space of an address is change.
diff -r avr/gcc/config/avr/avr-arch.h gcc/gcc/config/avr/avr-arch.h
38d37
<   ARCH_AVRTINY,
79,81d77
<   /* This is a TINY core. */
<   int tiny_p;
< 
107,109d102
<   /* device specific feature */
<   int dev_attribute;
< 
113,117c106,107
<   /* Start of data section.  */
<   int data_section_start;
< 
<   /* Start of text section. */
<   int text_section_start;
---
>   /* Stack pointer have 8 bits width.  */
>   int short_sp;
119,124c109,112
<   /* Number of 64k segments in the flash.  */
<   int n_flash;
< 
<   /* Name of device library.  */
<   const char *const library_name;
< } avr_mcu_t;
---
>   /* Some AVR devices have a core erratum when skipping a 2-word instruction.
>      Skip instructions are:  SBRC, SBRS, SBIC, SBIS, CPSE.
>      Problems will occur with return address is IRQ executes during the
>      skip sequence.
126c114
< /* AVR device specific features.
---
>      A support ticket from Atmel returned the following information:
128,130c116,118
< AVR_ISA_RMW
<   Only few avr devices have Read-Modify-Write (RMW) instructions
<   (XCH, LAC, LAS and LAT)
---
>          Subject: (ATTicket:644469) On AVR skip-bug core Erratum
>          From: avr@atmel.com                    Date: 2011-07-27
>          (Please keep the subject when replying to this mail)
132,134c120
< AVR_SHORT_SP
<   Stack Pointer has only 8 bit width.
<   The device / multilib has an 8-bit stack pointer (no SPH).
---
>          This errata exists only in AT90S8515 and ATmega103 devices.
136,140c122,124
< AVR_ERRATA_SKIP
<   Some AVR devices have a core erratum when skipping a 2-word instruction.
<   Skip instructions are:  SBRC, SBRS, SBIC, SBIS, CPSE.
<   Problems will occur with return address is IRQ executes during the
<   skip sequence.
---
>          For information please refer the following respective errata links
>             http://www.atmel.com/dyn/resources/prod_documents/doc2494.pdf
>             http://www.atmel.com/dyn/resources/prod_documents/doc1436.pdf  */
142c126,127
<   A support ticket from Atmel returned the following information:
---
>   /* Core Erratum:  Must not skip 2-word instruction.  */
>   int errata_skip;
144,148c129,130
<      Subject: (ATTicket:644469) On AVR skip-bug core Erratum
<      From: avr@atmel.com                    Date: 2011-07-27
<      (Please keep the subject when replying to this mail)
< 
<      This errata exists only in AT90S8515 and ATmega103 devices.
---
>   /* Start of data section.  */
>   int data_section_start;
150,152c132,133
<      For information please refer the following respective errata links
<        http://www.atmel.com/dyn/resources/prod_documents/doc2494.pdf
<        http://www.atmel.com/dyn/resources/prod_documents/doc1436.pdf  */
---
>   /* Number of 64k segments in the flash.  */
>   int n_flash;
154,160c135,137
< enum avr_device_specific_features
< {
<   AVR_ISA_NONE,
<   AVR_ISA_RMW     = 0x1, /* device has RMW instructions. */
<   AVR_SHORT_SP    = 0x2, /* Stack Pointer has 8 bits width. */
<   AVR_ERRATA_SKIP = 0x4  /* device has a core erratum. */
< };
---
>   /* Name of device library.  */
>   const char *const library_name;
> } avr_mcu_t;
diff -r avr/gcc/config/avr/avr-c.c gcc/gcc/config/avr/avr-c.c
301,305c301
<     {
<       cpp_define (pfile, avr_current_device->macro);
<       cpp_define_formatted (pfile, "__AVR_DEVICE_NAME__=%s",
< 			    avr_current_device->name);
<     }
---
>     cpp_define (pfile, avr_current_device->macro);
329,345d324
< 
<   if (AVR_TINY)
<     {
<       cpp_define (pfile, "__AVR_TINY__");
< 
<       /* Define macro "__AVR_TINY_PM_BASE_ADDRESS__" with mapped program memory
<          start address. This macro shall be referred where mapped program memory
<          is accessed. (Eg. copying data section (do_copy_data) contents to data
<          memory region.
<          NOTE:
<          Program memory of AVR_TINY devices can not be accessed directly, it has
<          been mapped to the data memory. For AVR_TINY devices (ATtiny4/ 5/ 9/ 10/
<          20 and 40) mapped program memory starts at 0x4000.
<       */
<       cpp_define (pfile, "__AVR_TINY_PM_BASE_ADDRESS__=0x4000");
<     }
< 
370c349
<   if (avr_current_device->dev_attribute & AVR_ERRATA_SKIP)
---
>   if (avr_current_device->errata_skip)
377,379d355
< 
<   if (avr_current_device->dev_attribute & AVR_ISA_RMW)
<     cpp_define (pfile, "__AVR_ISA_RMW__");
diff -r avr/gcc/config/avr/avr-devices.c gcc/gcc/config/avr/avr-devices.c
34c34
<   { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, NULL,  "avr2"  },
---
>   { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, NULL,              "avr2"  },
36,50c36,50
<     A  M  J  LM E  E  E  X  R  T  d S   S O   A
<     S  U  M  PO L  L  I  M  A  I  a t   F ff  r
<     M  L  P  MV P  P  J  E  M  N  t a   R s   c
<              XW M  M  M  G  P  Y  a r     e   h
<                    X  P  A  D       t     t   ID   */
<   { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, "1",   "avr1"  },
<   { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, "2",   "avr2"  },
<   { 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0x0060, 32, "25",  "avr25" },
<   { 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, "3",   "avr3"  },
<   { 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0x0060, 32, "31",  "avr31" },
<   { 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0x0060, 32, "35",  "avr35" },
<   { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0x0060, 32, "4",   "avr4"  },
<   { 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0x0060, 32, "5",   "avr5"  },
<   { 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0x0060, 32, "51",  "avr51" },
<   { 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0x0060, 32, "6",   "avr6"  },
---
>     A  M  J  LM E  E  E  X  R   d S   S O   A
>     S  U  M  PO L  L  I  M  A   a t   F ff  r
>     M  L  P  MV P  P  J  E  M   t a   R s   c
>              XW M  M  M  G  P   a r     e   h
>                    X  P  A  D     t     t   ID   */
>   { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, "1",   "avr1"  },
>   { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, "2",   "avr2"  },
>   { 0, 0, 0, 1, 0, 0, 0, 0, 0, 0x0060, 32, "25",  "avr25" },
>   { 0, 0, 1, 0, 0, 0, 0, 0, 0, 0x0060, 32, "3",   "avr3"  },
>   { 0, 0, 1, 0, 1, 0, 0, 0, 0, 0x0060, 32, "31",  "avr31" },
>   { 0, 0, 1, 1, 0, 0, 0, 0, 0, 0x0060, 32, "35",  "avr35" },
>   { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0x0060, 32, "4",   "avr4"  },
>   { 0, 1, 1, 1, 0, 0, 0, 0, 0, 0x0060, 32, "5",   "avr5"  },
>   { 0, 1, 1, 1, 1, 1, 0, 0, 0, 0x0060, 32, "51",  "avr51" },
>   { 0, 1, 1, 1, 1, 1, 1, 0, 0, 0x0060, 32, "6",   "avr6"  },
52,57c52,56
<   { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0x0040,  0, "100", "avrtiny" },
<   { 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0x2000,  0, "102", "avrxmega2" },
<   { 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0x2000,  0, "104", "avrxmega4" },
<   { 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0x2000,  0, "105", "avrxmega5" },
<   { 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0x2000,  0, "106", "avrxmega6" },
<   { 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0x2000,  0, "107", "avrxmega7" }
---
>   { 0, 1, 1, 1, 0, 0, 0, 1, 0, 0x2000,  0, "102", "avrxmega2" },
>   { 0, 1, 1, 1, 1, 1, 0, 1, 0, 0x2000,  0, "104", "avrxmega4" },
>   { 0, 1, 1, 1, 1, 1, 0, 1, 1, 0x2000,  0, "105", "avrxmega5" },
>   { 0, 1, 1, 1, 1, 1, 1, 1, 0, 0x2000,  0, "106", "avrxmega6" },
>   { 0, 1, 1, 1, 1, 1, 1, 1, 1, 0x2000,  0, "107", "avrxmega7" }
89,91d87
<   { ARCH_AVRTINY,
<     "``TINY'' Tiny core devices with 512@tie{}B up to 4@tie{}KiB of "
<     "program memory." },
111,112c107,108
< #define AVR_MCU(NAME, ARCH, DEV_ATTRIBUTE, MACRO, DATA_SEC, TEXT_SEC, N_FLASH, LIBNAME)\
<   { NAME, ARCH, DEV_ATTRIBUTE, MACRO, DATA_SEC, TEXT_SEC, N_FLASH, LIBNAME },
---
> #define AVR_MCU(NAME, ARCH, MACRO, SP8, ERR_SKIP, DATA_SEC, N_FLASH, LIBNAME)\
>   { NAME, ARCH, MACRO, SP8, ERR_SKIP, DATA_SEC, N_FLASH, LIBNAME },
116c112
<   { NULL, ARCH_UNKNOWN, AVR_ISA_NONE, NULL, 0, 0, 0, NULL }
---
>   { NULL, ARCH_UNKNOWN, NULL, 0, 0, 0, 0, NULL }
diff -r avr/gcc/config/avr/avr-fixed.md gcc/gcc/config/avr/avr-fixed.md
450,455c450,453
< (define_insn "round<mode>3_const"
<   [(set (match_operand:ALL124QA 0 "register_operand"                  "=d")
<         (unspec:ALL124QA [(match_operand:ALL124QA 1 "register_operand" "0")
<                           (match_operand:HI 2 "const_int_operand"      "n")
<                           (const_int 0)]
<                          UNSPEC_ROUND))]
---
> (define_expand "round<mode>3_const"
>   [(parallel [(match_operand:ALL124QA 0 "register_operand" "")
>               (match_operand:ALL124QA 1 "register_operand" "")
>               (match_operand:HI 2 "const_int_operand" "")])]
458,461c456,492
<     return avr_out_round (insn, operands);
<   }
<   [(set_attr "cc" "clobber")
<    (set_attr "adjust_len" "round")])
---
>     // The rounding point RP is $2.  The smallest fractional
>     // bit that is not cleared by the rounding is 2^(-RP).
> 
>     enum machine_mode imode = int_mode_for_mode (<MODE>mode);
>     int fbit = (int) GET_MODE_FBIT (<MODE>mode);
> 
>     // Add-Saturate  1/2 * 2^(-RP)
> 
>     double_int i_add = double_int_zero.set_bit (fbit-1 - INTVAL (operands[2]));
>     rtx x_add = const_fixed_from_double_int (i_add, <MODE>mode);
> 
>     if (SIGNED_FIXED_POINT_MODE_P (<MODE>mode))
>       emit_move_insn (operands[0],
>                       gen_rtx_SS_PLUS (<MODE>mode, operands[1], x_add));
>     else
>       emit_move_insn (operands[0],
>                       gen_rtx_US_PLUS (<MODE>mode, operands[1], x_add));
> 
>     // Keep  all bits from RP and higher:   ... 2^(-RP)
>     // Clear all bits from RP+1 and lower:              2^(-RP-1) ...
>     // Rounding point                           ^^^^^^^
>     // Added above                                      ^^^^^^^^^
> 
>     rtx xreg = simplify_gen_subreg (imode, operands[0], <MODE>mode, 0);
>     rtx xmask = immed_double_int_const (-i_add - i_add, imode);
> 
>     if (SImode == imode)
>       emit_insn (gen_andsi3 (xreg, xreg, xmask));
>     else if (HImode == imode)
>       emit_insn (gen_andhi3 (xreg, xreg, xmask));
>     else if (QImode == imode)
>       emit_insn (gen_andqi3 (xreg, xreg, xmask));
>     else
>       gcc_unreachable();
> 
>     DONE;
>   })
diff -r avr/gcc/config/avr/avr-mcus.def gcc/gcc/config/avr/avr-mcus.def
36c36,37
<    AVR_MCU (NAME, ARCH, DEV_ATTRIBUTE, MACRO, DATA_SEC, TEXT_SEC, N_FLASH, LIBRARY_NAME)
---
>    AVR_MCU (NAME, ARCH, MACRO, SHORT_SP, ERRATA_SKIP, DATA_SEC, N_FLASH,
>             LIBRARY_NAME)
40c41
<        NAME          Accept -mmcu=<NAME>
---
>        NAME         Accept -mmcu=<NAME>
42c43
<        ARCH          Specifies the multilib variant together with SHORT_SP
---
>        ARCH         Specifies the multilib variant together with SHORT_SP
44,45c45,46
<        DEV_ATTRIBUTE Specifies the device specific features
<                      - additional ISA, short SP, errata skip etc.,
---
>        MACRO        If NULL, this is a core and not a device.  If non-NULL,
>                     supply respective built-in macro.
47,48c48
<        MACRO         If NULL, this is a core and not a device.  If non-NULL,
<                      supply respective built-in macro.
---
>        SHORT_SP     The device / multilib has an 8-bit stack pointer (no SPH).
50c50,51
<        DATA_SEC      First address of SRAM, used in  -Tdata=  by the driver.
---
>        ERRATA_SKIP  Apply work-around for the "skip 32-bit instruction"
>                     silicon bug:  Don't skip 32-bit instrctions.
52c53
<        TEXT_SEC      First address of Flash, used in -Text= by the driver.
---
>        DATA_SEC     First address of SRAM, used in  -Tdata=  by the driver.
54c55
<        N_FLASH       Number of 64 KiB flash segments, rounded up.
---
>        N_FLASH      Number of 64 KiB flash segments, rounded up.
56,57c57,58
<        LIBRARY_NAME  Used by the driver to linke startup code from avr-libc
<                      as of  crt<LIBRARY_NAME>.o
---
>        LIBRARY_NAME Used by the driver to linke startup code from avr-libc
>                     as of  crt<LIBRARY_NAME>.o
61,276c62,271
< /* Classic, <= 8K, 2-byte PC.  */
< AVR_MCU ("avr2",                 ARCH_AVR2, AVR_ERRATA_SKIP, NULL,                     0x0060, 0x0, 6, "s8515")
< AVR_MCU ("at90s2313",            ARCH_AVR2, AVR_SHORT_SP, "__AVR_AT90S2313__",         0x0060, 0x0, 1, "s2313")
< AVR_MCU ("at90s2323",            ARCH_AVR2, AVR_SHORT_SP, "__AVR_AT90S2323__",         0x0060, 0x0, 1, "s2323")
< AVR_MCU ("at90s2333",            ARCH_AVR2, AVR_SHORT_SP, "__AVR_AT90S2333__",         0x0060, 0x0, 1, "s2333")
< AVR_MCU ("at90s2343",            ARCH_AVR2, AVR_SHORT_SP, "__AVR_AT90S2343__",         0x0060, 0x0, 1, "s2343")
< AVR_MCU ("attiny22",             ARCH_AVR2, AVR_SHORT_SP, "__AVR_ATtiny22__",          0x0060, 0x0, 1, "tn22")
< AVR_MCU ("attiny26",             ARCH_AVR2, AVR_SHORT_SP, "__AVR_ATtiny26__",          0x0060, 0x0, 1, "tn26")
< AVR_MCU ("at90s4414",            ARCH_AVR2, AVR_ISA_NONE, "__AVR_AT90S4414__",         0x0060, 0x0, 1, "s4414")
< AVR_MCU ("at90s4433",            ARCH_AVR2, AVR_SHORT_SP, "__AVR_AT90S4433__",         0x0060, 0x0, 1, "s4433")
< AVR_MCU ("at90s4434",            ARCH_AVR2, AVR_ISA_NONE, "__AVR_AT90S4434__",         0x0060, 0x0, 1, "s4434")
< AVR_MCU ("at90s8515",            ARCH_AVR2, AVR_ERRATA_SKIP, "__AVR_AT90S8515__",      0x0060, 0x0, 1, "s8515")
< AVR_MCU ("at90c8534",            ARCH_AVR2, AVR_ISA_NONE, "__AVR_AT90C8534__",         0x0060, 0x0, 1, "c8534")
< AVR_MCU ("at90s8535",            ARCH_AVR2, AVR_ISA_NONE, "__AVR_AT90S8535__",         0x0060, 0x0, 1, "s8535")
< /* Classic + MOVW/LPMX, <= 8K + 2-byte PC.  */
< AVR_MCU ("avr25",                ARCH_AVR25, AVR_ISA_NONE, NULL,                       0x0060, 0x0, 1, "tn85")
< AVR_MCU ("ata5272",              ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATA5272__",          0x0100, 0x0, 1, "a5272")
< AVR_MCU ("ata6616c",             ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATA6616C__",         0x0100, 0x0, 1, "a6616c")
< AVR_MCU ("attiny13",             ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny13__",         0x0060, 0x0, 1, "tn13")
< AVR_MCU ("attiny13a",            ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny13A__",        0x0060, 0x0, 1, "tn13a")
< AVR_MCU ("attiny2313",           ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny2313__",       0x0060, 0x0, 1, "tn2313")
< AVR_MCU ("attiny2313a",          ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny2313A__",      0x0060, 0x0, 1, "tn2313a")
< AVR_MCU ("attiny24",             ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny24__",         0x0060, 0x0, 1, "tn24")
< AVR_MCU ("attiny24a",            ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny24A__",        0x0060, 0x0, 1, "tn24a")
< AVR_MCU ("attiny4313",           ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny4313__",       0x0060, 0x0, 1, "tn4313")
< AVR_MCU ("attiny44",             ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny44__",         0x0060, 0x0, 1, "tn44")
< AVR_MCU ("attiny44a",            ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny44A__",        0x0060, 0x0, 1, "tn44a")
< AVR_MCU ("attiny441",			 ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny441__",		   0x0100, 0x0, 1, "tn441")
< AVR_MCU ("attiny84",             ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny84__",         0x0060, 0x0, 1, "tn84")
< AVR_MCU ("attiny84a",            ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny84A__",        0x0060, 0x0, 1, "tn84")
< AVR_MCU ("attiny25",             ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny25__",         0x0060, 0x0, 1, "tn25")
< AVR_MCU ("attiny45",             ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny45__",         0x0060, 0x0, 1, "tn45")
< AVR_MCU ("attiny85",             ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny85__",         0x0060, 0x0, 1, "tn85")
< AVR_MCU ("attiny261",            ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny261__",        0x0060, 0x0, 1, "tn261")
< AVR_MCU ("attiny261a",           ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny261A__",       0x0060, 0x0, 1, "tn261a")
< AVR_MCU ("attiny461",            ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny461__",        0x0060, 0x0, 1, "tn461")
< AVR_MCU ("attiny461a",           ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny461A__",       0x0060, 0x0, 1, "tn461a")
< AVR_MCU ("attiny861",            ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny861__",        0x0060, 0x0, 1, "tn861")
< AVR_MCU ("attiny861a",           ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny861A__",       0x0060, 0x0, 1, "tn861a")
< AVR_MCU ("attiny43u",            ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny43U__",        0x0060, 0x0, 1, "tn43u")
< AVR_MCU ("attiny87",             ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny87__",         0x0100, 0x0, 1, "tn87")
< AVR_MCU ("attiny48",             ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny48__",         0x0100, 0x0, 1, "tn48")
< AVR_MCU ("attiny88",             ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny88__",         0x0100, 0x0, 1, "tn88")
< AVR_MCU ("attiny828",            ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny828__",        0x0100, 0x0, 1, "tn828")
< AVR_MCU ("attiny841",            ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny841__",        0x0100, 0x0, 1, "tn841")
< AVR_MCU ("at86rf401",            ARCH_AVR25, AVR_ISA_NONE, "__AVR_AT86RF401__",        0x0060, 0x0, 1, "86401")
< /* Classic, > 8K, <= 64K + 2-byte PC + { JMP/CALL }.  */
< AVR_MCU ("avr3",                 ARCH_AVR3, AVR_ISA_NONE, NULL,                        0x0060, 0x0, 1, "43355")
< AVR_MCU ("at43usb355",           ARCH_AVR3, AVR_ISA_NONE, "__AVR_AT43USB355__",        0x0060, 0x0, 1, "43355")
< AVR_MCU ("at76c711",             ARCH_AVR3, AVR_ISA_NONE, "__AVR_AT76C711__",          0x0060, 0x0, 1, "76711")
< /* Classic, == 128K + 2-byte PC + {JMP/CALL, ELPM }.  */
< AVR_MCU ("avr31",                ARCH_AVR31, AVR_ERRATA_SKIP, NULL,                    0x0060, 0x0, 2, "m103")
< AVR_MCU ("atmega103",            ARCH_AVR31, AVR_ERRATA_SKIP, "__AVR_ATmega103__",     0x0060, 0x0, 2, "m103")
< AVR_MCU ("at43usb320",           ARCH_AVR31, AVR_ISA_NONE, "__AVR_AT43USB320__",       0x0060, 0x0, 2, "43320")
< /* Classic, >=16K, <=64K + 2-byte PC + MOVW/LPMX + JMP/CALL.  */
< AVR_MCU ("avr35",                ARCH_AVR35, AVR_ISA_NONE, NULL,                       0x0100, 0x0, 1, "usb162")
< AVR_MCU ("ata5505",              ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATA5505__",          0x0100, 0x0, 1, "a5505")
< AVR_MCU ("ata6617c",             ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATA6617C__",         0x0100, 0x0, 1, "a6617c")
< AVR_MCU ("ata664251",            ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATA664251__",        0x0100, 0x0, 1, "a664251")
< AVR_MCU ("at90usb82",            ARCH_AVR35, AVR_ISA_NONE, "__AVR_AT90USB82__",        0x0100, 0x0, 1, "usb82")
< AVR_MCU ("at90usb162",           ARCH_AVR35, AVR_ISA_NONE, "__AVR_AT90USB162__",       0x0100, 0x0, 1, "usb162")
< AVR_MCU ("atmega8u2",            ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATmega8U2__",        0x0100, 0x0, 1, "m8u2")
< AVR_MCU ("atmega16u2",           ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATmega16U2__",       0x0100, 0x0, 1, "m16u2")
< AVR_MCU ("atmega32u2",           ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATmega32U2__",       0x0100, 0x0, 1, "m32u2")
< AVR_MCU ("attiny167",            ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATtiny167__",        0x0100, 0x0, 1, "tn167")
< AVR_MCU ("attiny1634",           ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATtiny1634__",       0x0100, 0x0, 1, "tn1634")
< /* Enhanced, <= 8K + 2-byte PC + { MOVW/LPMX, MUL }.  */
< AVR_MCU ("avr4",                 ARCH_AVR4, AVR_ISA_NONE, NULL,                        0x0060, 0x0, 1, "m8")
< AVR_MCU ("ata6285",              ARCH_AVR4, AVR_ISA_NONE, "__AVR_ATA6285__",           0x0100, 0x0, 1, "a6285")
< AVR_MCU ("ata6286",              ARCH_AVR4, AVR_ISA_NONE, "__AVR_ATA6286__",           0x0100, 0x0, 1, "a6286")
< AVR_MCU ("ata6289",              ARCH_AVR4, AVR_ISA_NONE, "__AVR_ATA6289__",           0x0100, 0x0, 1, "a6289")
< AVR_MCU ("ata6612c",             ARCH_AVR4, AVR_ISA_NONE, "__AVR_ATA6612C__",          0x0100, 0x0, 1, "a6612c")
< AVR_MCU ("atmega8",              ARCH_AVR4, AVR_ISA_NONE, "__AVR_ATmega8__",           0x0060, 0x0, 1, "m8")
< AVR_MCU ("atmega8a",             ARCH_AVR4, AVR_ISA_NONE, "__AVR_ATmega8A__",          0x0060, 0x0, 1, "m8a")
< AVR_MCU ("atmega48",             ARCH_AVR4, AVR_ISA_NONE, "__AVR_ATmega48__",          0x0100, 0x0, 1, "m48")
< AVR_MCU ("atmega48a",            ARCH_AVR4, AVR_ISA_NONE, "__AVR_ATmega48A__",         0x0100, 0x0, 1, "m48a")
< AVR_MCU ("atmega48p",            ARCH_AVR4, AVR_ISA_NONE, "__AVR_ATmega48P__",         0x0100, 0x0, 1, "m48p")
< AVR_MCU ("atmega48pa",           ARCH_AVR4, AVR_ISA_NONE, "__AVR_ATmega48PA__",        0x0100, 0x0, 1, "m48pa")
< AVR_MCU ("atmega48pb",           ARCH_AVR4, AVR_ISA_NONE, "__AVR_ATmega48PB__",        0x0100, 0x0, 1, "m48pb")
< AVR_MCU ("atmega88",             ARCH_AVR4, AVR_ISA_NONE, "__AVR_ATmega88__",          0x0100, 0x0, 1, "m88")
< AVR_MCU ("atmega88a",            ARCH_AVR4, AVR_ISA_NONE, "__AVR_ATmega88A__",         0x0100, 0x0, 1, "m88a")
< AVR_MCU ("atmega88p",            ARCH_AVR4, AVR_ISA_NONE, "__AVR_ATmega88P__",         0x0100, 0x0, 1, "m88p")
< AVR_MCU ("atmega88pa",           ARCH_AVR4, AVR_ISA_NONE, "__AVR_ATmega88PA__",        0x0100, 0x0, 1, "m88pa")
< AVR_MCU ("atmega88pb",           ARCH_AVR4, AVR_ISA_NONE, "__AVR_ATmega88PB__",        0x0100, 0x0, 1, "m88pb")
< AVR_MCU ("atmega8515",           ARCH_AVR4, AVR_ISA_NONE, "__AVR_ATmega8515__",        0x0060, 0x0, 1, "m8515")
< AVR_MCU ("atmega8535",           ARCH_AVR4, AVR_ISA_NONE, "__AVR_ATmega8535__",        0x0060, 0x0, 1, "m8535")
< AVR_MCU ("atmega8hva",           ARCH_AVR4, AVR_ISA_NONE, "__AVR_ATmega8HVA__",        0x0100, 0x0, 1, "m8hva")
< AVR_MCU ("at90pwm1",             ARCH_AVR4, AVR_ISA_NONE, "__AVR_AT90PWM1__",          0x0100, 0x0, 1, "90pwm1")
< AVR_MCU ("at90pwm2",             ARCH_AVR4, AVR_ISA_NONE, "__AVR_AT90PWM2__",          0x0100, 0x0, 1, "90pwm2")
< AVR_MCU ("at90pwm2b",            ARCH_AVR4, AVR_ISA_NONE, "__AVR_AT90PWM2B__",         0x0100, 0x0, 1, "90pwm2b")
< AVR_MCU ("at90pwm3",             ARCH_AVR4, AVR_ISA_NONE, "__AVR_AT90PWM3__",          0x0100, 0x0, 1, "90pwm3")
< AVR_MCU ("at90pwm3b",            ARCH_AVR4, AVR_ISA_NONE, "__AVR_AT90PWM3B__",         0x0100, 0x0, 1, "90pwm3b")
< AVR_MCU ("at90pwm81",            ARCH_AVR4, AVR_ISA_NONE, "__AVR_AT90PWM81__",         0x0100, 0x0, 1, "90pwm81")
< /* Enhanced, > 8K, <= 64K + 2-byte PC + { MOVW/LPMX, JMP/CALL, MUL }.  */
< AVR_MCU ("avr5",                 ARCH_AVR5, AVR_ISA_NONE, NULL,                        0x0060, 0x0, 1, "m16")
< AVR_MCU ("ata5702m322",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA5702M322__",       0x0200, 0x0, 1, "a5702m322")
< AVR_MCU ("ata5782",              ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA5782__",           0x0200, 0x8000, 1, "a5782")
< AVR_MCU ("ata5790",              ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA5790__",           0x0100, 0x0, 1, "a5790")
< AVR_MCU ("ata5790n",             ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA5790N__",          0x0100, 0x0, 1, "a5790n")
< AVR_MCU ("ata5795",              ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA5795__",           0x0100, 0x0, 1, "a5795")
< AVR_MCU ("ata5831",              ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA5831__",           0x0200, 0x8000, 1, "a5831")
< AVR_MCU ("ata6613c",             ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA6613C__",          0x0100, 0x0, 1, "a6613c")
< AVR_MCU ("ata6614q",             ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA6614Q__",          0x0100, 0x0, 1, "a6614q")
< AVR_MCU ("atmega16",             ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16__",          0x0060, 0x0, 1, "m16")
< AVR_MCU ("atmega16a",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16A__",         0x0060, 0x0, 1, "m16a")
< AVR_MCU ("atmega161",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega161__",         0x0060, 0x0, 1, "m161")
< AVR_MCU ("atmega162",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega162__",         0x0100, 0x0, 1, "m162")
< AVR_MCU ("atmega163",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega163__",         0x0060, 0x0, 1, "m163")
< AVR_MCU ("atmega164a",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega164A__",        0x0100, 0x0, 1, "m164a")
< AVR_MCU ("atmega164p",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega164P__",        0x0100, 0x0, 1, "m164p")
< AVR_MCU ("atmega164pa",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega164PA__",       0x0100, 0x0, 1, "m164pa")
< AVR_MCU ("atmega165",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega165__",         0x0100, 0x0, 1, "m165")
< AVR_MCU ("atmega165a",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega165A__",        0x0100, 0x0, 1, "m165a")
< AVR_MCU ("atmega165p",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega165P__",        0x0100, 0x0, 1, "m165p")
< AVR_MCU ("atmega165pa",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega165PA__",       0x0100, 0x0, 1, "m165pa")
< AVR_MCU ("atmega168",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega168__",         0x0100, 0x0, 1, "m168")
< AVR_MCU ("atmega168a",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega168A__",        0x0100, 0x0, 1, "m168a")
< AVR_MCU ("atmega168p",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega168P__",        0x0100, 0x0, 1, "m168p")
< AVR_MCU ("atmega168pa",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega168PA__",       0x0100, 0x0, 1, "m168pa")
< AVR_MCU ("atmega168pb",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega168PB__",       0x0100, 0x0, 1, "m168pb")
< AVR_MCU ("atmega169",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega169__",         0x0100, 0x0, 1, "m169")
< AVR_MCU ("atmega169a",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega169A__",        0x0100, 0x0, 1, "m169a")
< AVR_MCU ("atmega169p",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega169P__",        0x0100, 0x0, 1, "m169p")
< AVR_MCU ("atmega169pa",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega169PA__",       0x0100, 0x0, 1, "m169pa")
< AVR_MCU ("atmega16hvb",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16HVB__",       0x0100, 0x0, 1, "m16hvb")
< AVR_MCU ("atmega16hvbrevb",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16HVBREVB__",   0x0100, 0x0, 1, "m16hvbrevb")
< AVR_MCU ("atmega16m1",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16M1__",        0x0100, 0x0, 1, "m16m1")
< AVR_MCU ("atmega16u4",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16U4__",        0x0100, 0x0, 1, "m16u4")
< AVR_MCU ("atmega32a",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32A__",         0x0060, 0x0, 1, "m32a")
< AVR_MCU ("atmega32",             ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32__",          0x0060, 0x0, 1, "m32")
< AVR_MCU ("atmega323",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega323__",         0x0060, 0x0, 1, "m323")
< AVR_MCU ("atmega324a",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega324A__",        0x0100, 0x0, 1, "m324a")
< AVR_MCU ("atmega324p",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega324P__",        0x0100, 0x0, 1, "m324p")
< AVR_MCU ("atmega324pa",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega324PA__",       0x0100, 0x0, 1, "m324pa")
< AVR_MCU ("atmega325",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega325__",         0x0100, 0x0, 1, "m325")
< AVR_MCU ("atmega325a",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega325A__",        0x0100, 0x0, 1, "m325a")
< AVR_MCU ("atmega325p",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega325P__",        0x0100, 0x0, 1, "m325p")
< AVR_MCU ("atmega325pa",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega325PA__",       0x0100, 0x0, 1, "m325pa")
< AVR_MCU ("atmega3250",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3250__",        0x0100, 0x0, 1, "m3250")
< AVR_MCU ("atmega3250a",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3250A__",       0x0100, 0x0, 1, "m3250a")
< AVR_MCU ("atmega3250p",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3250P__",       0x0100, 0x0, 1, "m3250p")
< AVR_MCU ("atmega3250pa",         ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3250PA__",      0x0100, 0x0, 1, "m3250pa")
< AVR_MCU ("atmega328",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega328__",         0x0100, 0x0, 1, "m328")
< AVR_MCU ("atmega328p",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega328P__",        0x0100, 0x0, 1, "m328p")
< AVR_MCU ("atmega329",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega329__",         0x0100, 0x0, 1, "m329")
< AVR_MCU ("atmega329a",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega329A__",        0x0100, 0x0, 1, "m329a")
< AVR_MCU ("atmega329p",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega329P__",        0x0100, 0x0, 1, "m329p")
< AVR_MCU ("atmega329pa",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega329PA__",       0x0100, 0x0, 1, "m329pa")
< AVR_MCU ("atmega3290",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3290__",        0x0100, 0x0, 1, "m3290")
< AVR_MCU ("atmega3290a",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3290A__",       0x0100, 0x0, 1, "m3290a")
< AVR_MCU ("atmega3290p",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3290P__",       0x0100, 0x0, 1, "m3290p")
< AVR_MCU ("atmega3290pa",         ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3290PA__",      0x0100, 0x0, 1, "m3290pa")
< AVR_MCU ("atmega32c1",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32C1__",        0x0100, 0x0, 1, "m32c1")
< AVR_MCU ("atmega32m1",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32M1__",        0x0100, 0x0, 1, "m32m1")
< AVR_MCU ("atmega32u4",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32U4__",        0x0100, 0x0, 1, "m32u4")
< AVR_MCU ("atmega32u6",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32U6__",        0x0100, 0x0, 1, "m32u6")
< AVR_MCU ("atmega406",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega406__",         0x0100, 0x0, 1, "m406")
< AVR_MCU ("atmega64",             ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64__",          0x0100, 0x0, 1, "m64")
< AVR_MCU ("atmega64a",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64A__",         0x0100, 0x0, 1, "m64a")
< AVR_MCU ("atmega640",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega640__",         0x0200, 0x0, 1, "m640")
< AVR_MCU ("atmega644",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega644__",         0x0100, 0x0, 1, "m644")
< AVR_MCU ("atmega644a",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega644A__",        0x0100, 0x0, 1, "m644a")
< AVR_MCU ("atmega644p",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega644P__",        0x0100, 0x0, 1, "m644p")
< AVR_MCU ("atmega644pa",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega644PA__",       0x0100, 0x0, 1, "m644pa")
< AVR_MCU ("atmega645",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega645__",         0x0100, 0x0, 1, "m645")
< AVR_MCU ("atmega645a",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega645A__",        0x0100, 0x0, 1, "m645a")
< AVR_MCU ("atmega645p",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega645P__",        0x0100, 0x0, 1, "m645p")
< AVR_MCU ("atmega6450",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega6450__",        0x0100, 0x0, 1, "m6450")
< AVR_MCU ("atmega6450a",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega6450A__",       0x0100, 0x0, 1, "m6450a")
< AVR_MCU ("atmega6450p",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega6450P__",       0x0100, 0x0, 1, "m6450p")
< AVR_MCU ("atmega649",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega649__",         0x0100, 0x0, 1, "m649")
< AVR_MCU ("atmega649a",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega649A__",        0x0100, 0x0, 1, "m649a")
< AVR_MCU ("atmega649p",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega649P__",        0x0100, 0x0, 1, "m649p")
< AVR_MCU ("atmega6490",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega6490__",        0x0100, 0x0, 1, "m6490")
< AVR_MCU ("atmega16hva",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16HVA__",       0x0100, 0x0, 1, "m16hva")
< AVR_MCU ("atmega16hva2",         ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16HVA2__",      0x0100, 0x0, 1, "m16hva2")
< AVR_MCU ("atmega32hvb",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32HVB__",       0x0100, 0x0, 1, "m32hvb")
< AVR_MCU ("atmega6490a",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega6490A__",       0x0100, 0x0, 1, "m6490a")
< AVR_MCU ("atmega6490p",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega6490P__",       0x0100, 0x0, 1, "m6490p")
< AVR_MCU ("atmega64c1",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64C1__",        0x0100, 0x0, 1, "m64c1")
< AVR_MCU ("atmega64m1",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64M1__",        0x0100, 0x0, 1, "m64m1")
< AVR_MCU ("atmega64hve",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64HVE__",       0x0100, 0x0, 1, "m64hve")
< AVR_MCU ("atmega64hve2",         ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64HVE2__",      0x0100, 0x0, 1, "m64hve2")
< AVR_MCU ("atmega64rfr2",         ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64RFR2__",      0x0200, 0x0, 1, "m64rfr2")
< AVR_MCU ("atmega644rfr2",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega644RFR2__",     0x0200, 0x0, 1, "m644rfr2")
< AVR_MCU ("atmega32hvbrevb",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32HVBREVB__",   0x0100, 0x0, 1, "m32hvbrevb")
< AVR_MCU ("at90can32",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90CAN32__",         0x0100, 0x0, 1, "can32")
< AVR_MCU ("at90can64",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90CAN64__",         0x0100, 0x0, 1, "can64")
< AVR_MCU ("at90pwm161",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90PWM161__",        0x0100, 0x0, 1, "90pwm161")
< AVR_MCU ("at90pwm216",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90PWM216__",        0x0100, 0x0, 1, "90pwm216")
< AVR_MCU ("at90pwm316",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90PWM316__",        0x0100, 0x0, 1, "90pwm316")
< AVR_MCU ("at90scr100",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90SCR100__",        0x0100, 0x0, 1, "90scr100")
< AVR_MCU ("at90usb646",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90USB646__",        0x0100, 0x0, 1, "usb646")
< AVR_MCU ("at90usb647",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90USB647__",        0x0100, 0x0, 1, "usb647")
< AVR_MCU ("at94k",                ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT94K__",             0x0060, 0x0, 1, "at94k")
< AVR_MCU ("m3000",                ARCH_AVR5, AVR_ISA_NONE, "__AVR_M3000__",             0x1000, 0x0, 1, "m3000")
< /* Enhanced, == 128K + 2-byte PC + { MOVW/LPMX, JMP/CALL, MUL, ELPM, ELPMX }.  */
< AVR_MCU ("avr51",                ARCH_AVR51, AVR_ISA_NONE, NULL,                       0x0100, 0x0, 2, "m128")
< AVR_MCU ("atmega128",            ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega128__",        0x0100, 0x0, 2, "m128")
< AVR_MCU ("atmega128a",           ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega128A__",       0x0100, 0x0, 2, "m128a")
< AVR_MCU ("atmega1280",           ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega1280__",       0x0200, 0x0, 2, "m1280")
< AVR_MCU ("atmega1281",           ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega1281__",       0x0200, 0x0, 2, "m1281")
< AVR_MCU ("atmega1284",           ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega1284__",       0x0100, 0x0, 2, "m1284")
< AVR_MCU ("atmega1284p",          ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega1284P__",      0x0100, 0x0, 2, "m1284p")
< AVR_MCU ("atmega128rfa1",        ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega128RFA1__",    0x0200, 0x0, 2, "m128rfa1")
< AVR_MCU ("atmega128rfr2",        ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega128RFR2__",    0x0200, 0x0, 2, "m128rfr2")
< AVR_MCU ("atmega1284rfr2",       ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega1284RFR2__",   0x0200, 0x0, 2, "m1284rfr2")
< AVR_MCU ("at90can128",           ARCH_AVR51, AVR_ISA_NONE, "__AVR_AT90CAN128__",       0x0100, 0x0, 2, "can128")
< AVR_MCU ("at90usb1286",          ARCH_AVR51, AVR_ISA_NONE, "__AVR_AT90USB1286__",      0x0100, 0x0, 2, "usb1286")
< AVR_MCU ("at90usb1287",          ARCH_AVR51, AVR_ISA_NONE, "__AVR_AT90USB1287__",      0x0100, 0x0, 2, "usb1287")
< /* Enhanced, == 256K + 3-Byte PC + { MOVW/LPMX, JMP/CALL, MUL, ELPM, ELPMX }.  */
< AVR_MCU ("avr6",                 ARCH_AVR6, AVR_ISA_NONE, NULL,                        0x0200, 0x0, 4, "m2561")
< AVR_MCU ("atmega2560",           ARCH_AVR6, AVR_ISA_NONE, "__AVR_ATmega2560__",        0x0200, 0x0, 4, "m2560")
< AVR_MCU ("atmega2561",           ARCH_AVR6, AVR_ISA_NONE, "__AVR_ATmega2561__",        0x0200, 0x0, 4, "m2561")
< AVR_MCU ("atmega256rfr2",        ARCH_AVR6, AVR_ISA_NONE, "__AVR_ATmega256RFR2__",     0x0200, 0x0, 4, "m256rfr2")
< AVR_MCU ("atmega2564rfr2",       ARCH_AVR6, AVR_ISA_NONE, "__AVR_ATmega2564RFR2__",    0x0200, 0x0, 4, "m2564rfr2")
---
> /* Classic, <= 8K.  */
> AVR_MCU ("avr2",                 ARCH_AVR2, NULL,                        0, 1, 0x0060, 6, "s8515")
> AVR_MCU ("at90s2313",            ARCH_AVR2, "__AVR_AT90S2313__",         1, 0, 0x0060, 1, "s2313")
> AVR_MCU ("at90s2323",            ARCH_AVR2, "__AVR_AT90S2323__",         1, 0, 0x0060, 1, "s2323")
> AVR_MCU ("at90s2333",            ARCH_AVR2, "__AVR_AT90S2333__",         1, 0, 0x0060, 1, "s2333")
> AVR_MCU ("at90s2343",            ARCH_AVR2, "__AVR_AT90S2343__",         1, 0, 0x0060, 1, "s2343")
> AVR_MCU ("attiny22",             ARCH_AVR2, "__AVR_ATtiny22__",          1, 0, 0x0060, 1, "tn22")
> AVR_MCU ("attiny26",             ARCH_AVR2, "__AVR_ATtiny26__",          1, 0, 0x0060, 1, "tn26")
> AVR_MCU ("at90s4414",            ARCH_AVR2, "__AVR_AT90S4414__",         0, 0, 0x0060, 1, "s4414")
> AVR_MCU ("at90s4433",            ARCH_AVR2, "__AVR_AT90S4433__",         1, 0, 0x0060, 1, "s4433")
> AVR_MCU ("at90s4434",            ARCH_AVR2, "__AVR_AT90S4434__",         0, 0, 0x0060, 1, "s4434")
> AVR_MCU ("at90s8515",            ARCH_AVR2, "__AVR_AT90S8515__",         0, 1, 0x0060, 1, "s8515")
> AVR_MCU ("at90c8534",            ARCH_AVR2, "__AVR_AT90C8534__",         0, 0, 0x0060, 1, "c8534")
> AVR_MCU ("at90s8535",            ARCH_AVR2, "__AVR_AT90S8535__",         0, 0, 0x0060, 1, "s8535")
> /* Classic + MOVW, <= 8K.  */
> AVR_MCU ("avr25",                ARCH_AVR25, NULL,                       0, 0, 0x0060, 1, "tn85")
> AVR_MCU ("ata6289",              ARCH_AVR25, "__AVR_ATA6289__",          0, 0, 0x0100, 1, "a6289")
> AVR_MCU ("ata5272",              ARCH_AVR25, "__AVR_ATA5272__",          0, 0, 0x0100, 1, "a5272")
> AVR_MCU ("attiny13",             ARCH_AVR25, "__AVR_ATtiny13__",         1, 0, 0x0060, 1, "tn13")
> AVR_MCU ("attiny13a",            ARCH_AVR25, "__AVR_ATtiny13A__",        1, 0, 0x0060, 1, "tn13a")
> AVR_MCU ("attiny2313",           ARCH_AVR25, "__AVR_ATtiny2313__",       1, 0, 0x0060, 1, "tn2313")
> AVR_MCU ("attiny2313a",          ARCH_AVR25, "__AVR_ATtiny2313A__",      1, 0, 0x0060, 1, "tn2313a")
> AVR_MCU ("attiny24",             ARCH_AVR25, "__AVR_ATtiny24__",         1, 0, 0x0060, 1, "tn24")
> AVR_MCU ("attiny24a",            ARCH_AVR25, "__AVR_ATtiny24A__",        1, 0, 0x0060, 1, "tn24a")
> AVR_MCU ("attiny4313",           ARCH_AVR25, "__AVR_ATtiny4313__",       0, 0, 0x0060, 1, "tn4313")
> AVR_MCU ("attiny44",             ARCH_AVR25, "__AVR_ATtiny44__",         0, 0, 0x0060, 1, "tn44")
> AVR_MCU ("attiny44a",            ARCH_AVR25, "__AVR_ATtiny44A__",        0, 0, 0x0060, 1, "tn44a")
> AVR_MCU ("attiny84",             ARCH_AVR25, "__AVR_ATtiny84__",         0, 0, 0x0060, 1, "tn84")
> AVR_MCU ("attiny84a",            ARCH_AVR25, "__AVR_ATtiny84A__",        0, 0, 0x0060, 1, "tn84")
> AVR_MCU ("attiny25",             ARCH_AVR25, "__AVR_ATtiny25__",         1, 0, 0x0060, 1, "tn25")
> AVR_MCU ("attiny45",             ARCH_AVR25, "__AVR_ATtiny45__",         0, 0, 0x0060, 1, "tn45")
> AVR_MCU ("attiny85",             ARCH_AVR25, "__AVR_ATtiny85__",         0, 0, 0x0060, 1, "tn85")
> AVR_MCU ("attiny261",            ARCH_AVR25, "__AVR_ATtiny261__",        1, 0, 0x0060, 1, "tn261")
> AVR_MCU ("attiny261a",           ARCH_AVR25, "__AVR_ATtiny261A__",       1, 0, 0x0060, 1, "tn261a")
> AVR_MCU ("attiny461",            ARCH_AVR25, "__AVR_ATtiny461__",        0, 0, 0x0060, 1, "tn461")
> AVR_MCU ("attiny461a",           ARCH_AVR25, "__AVR_ATtiny461A__",       0, 0, 0x0060, 1, "tn461a")
> AVR_MCU ("attiny861",            ARCH_AVR25, "__AVR_ATtiny861__",        0, 0, 0x0060, 1, "tn861")
> AVR_MCU ("attiny861a",           ARCH_AVR25, "__AVR_ATtiny861A__",       0, 0, 0x0060, 1, "tn861a")
> AVR_MCU ("attiny43u",            ARCH_AVR25, "__AVR_ATtiny43U__",        0, 0, 0x0060, 1, "tn43u")
> AVR_MCU ("attiny87",             ARCH_AVR25, "__AVR_ATtiny87__",         0, 0, 0x0100, 1, "tn87")
> AVR_MCU ("attiny48",             ARCH_AVR25, "__AVR_ATtiny48__",         0, 0, 0x0100, 1, "tn48")
> AVR_MCU ("attiny88",             ARCH_AVR25, "__AVR_ATtiny88__",         0, 0, 0x0100, 1, "tn88")
> AVR_MCU ("at86rf401",            ARCH_AVR25, "__AVR_AT86RF401__",        0, 0, 0x0060, 1, "86401")
> /* Classic, > 8K, <= 64K.  */
> AVR_MCU ("avr3",                 ARCH_AVR3, NULL,                        0, 0, 0x0060, 1, "43355")
> AVR_MCU ("at43usb355",           ARCH_AVR3, "__AVR_AT43USB355__",        0, 0, 0x0060, 1, "43355")
> AVR_MCU ("at76c711",             ARCH_AVR3, "__AVR_AT76C711__",          0, 0, 0x0060, 1, "76711")
> /* Classic, == 128K.  */
> AVR_MCU ("avr31",                ARCH_AVR31, NULL,                       0, 1, 0x0060, 2, "m103")
> AVR_MCU ("atmega103",            ARCH_AVR31, "__AVR_ATmega103__",        0, 1, 0x0060, 2, "m103")
> AVR_MCU ("at43usb320",           ARCH_AVR31, "__AVR_AT43USB320__",       0, 0, 0x0060, 2, "43320")
> /* Classic + MOVW + JMP/CALL.  */
> AVR_MCU ("avr35",                ARCH_AVR35, NULL,                       0, 0, 0x0100, 1, "usb162")
> AVR_MCU ("ata5505",              ARCH_AVR35, "__AVR_ATA5505__",          0, 0, 0x0100, 1, "a5505")
> AVR_MCU ("at90usb82",            ARCH_AVR35, "__AVR_AT90USB82__",        0, 0, 0x0100, 1, "usb82")
> AVR_MCU ("at90usb162",           ARCH_AVR35, "__AVR_AT90USB162__",       0, 0, 0x0100, 1, "usb162")
> AVR_MCU ("atmega8u2",            ARCH_AVR35, "__AVR_ATmega8U2__",        0, 0, 0x0100, 1, "m8u2")
> AVR_MCU ("atmega16u2",           ARCH_AVR35, "__AVR_ATmega16U2__",       0, 0, 0x0100, 1, "m16u2")
> AVR_MCU ("atmega32u2",           ARCH_AVR35, "__AVR_ATmega32U2__",       0, 0, 0x0100, 1, "m32u2")
> AVR_MCU ("attiny167",            ARCH_AVR35, "__AVR_ATtiny167__",        0, 0, 0x0100, 1, "tn167")
> AVR_MCU ("attiny1634",           ARCH_AVR35, "__AVR_ATtiny1634__",       0, 0, 0x0100, 1, "tn1634")
> /* Enhanced, <= 8K.  */
> AVR_MCU ("avr4",                 ARCH_AVR4, NULL,                        0, 0, 0x0060, 1, "m8")
> AVR_MCU ("ata6285",              ARCH_AVR4, "__AVR_ATA6285__",           0, 0, 0x0100, 1, "a6285")
> AVR_MCU ("ata6286",              ARCH_AVR4, "__AVR_ATA6286__",           0, 0, 0x0100, 1, "a6286")
> AVR_MCU ("atmega8",              ARCH_AVR4, "__AVR_ATmega8__",           0, 0, 0x0060, 1, "m8")
> AVR_MCU ("atmega8a",             ARCH_AVR4, "__AVR_ATmega8A__",          0, 0, 0x0060, 1, "m8a")
> AVR_MCU ("atmega48",             ARCH_AVR4, "__AVR_ATmega48__",          0, 0, 0x0100, 1, "m48")
> AVR_MCU ("atmega48a",            ARCH_AVR4, "__AVR_ATmega48A__",         0, 0, 0x0100, 1, "m48a")
> AVR_MCU ("atmega48p",            ARCH_AVR4, "__AVR_ATmega48P__",         0, 0, 0x0100, 1, "m48p")
> AVR_MCU ("atmega48pa",           ARCH_AVR4, "__AVR_ATmega48PA__",        0, 0, 0x0100, 1, "m48pa")
> AVR_MCU ("atmega88",             ARCH_AVR4, "__AVR_ATmega88__",          0, 0, 0x0100, 1, "m88")
> AVR_MCU ("atmega88a",            ARCH_AVR4, "__AVR_ATmega88A__",         0, 0, 0x0100, 1, "m88a")
> AVR_MCU ("atmega88p",            ARCH_AVR4, "__AVR_ATmega88P__",         0, 0, 0x0100, 1, "m88p")
> AVR_MCU ("atmega88pa",           ARCH_AVR4, "__AVR_ATmega88PA__",        0, 0, 0x0100, 1, "m88pa")
> AVR_MCU ("atmega8515",           ARCH_AVR4, "__AVR_ATmega8515__",        0, 0, 0x0060, 1, "m8515")
> AVR_MCU ("atmega8535",           ARCH_AVR4, "__AVR_ATmega8535__",        0, 0, 0x0060, 1, "m8535")
> AVR_MCU ("atmega8hva",           ARCH_AVR4, "__AVR_ATmega8HVA__",        0, 0, 0x0100, 1, "m8hva")
> AVR_MCU ("at90pwm1",             ARCH_AVR4, "__AVR_AT90PWM1__",          0, 0, 0x0100, 1, "90pwm1")
> AVR_MCU ("at90pwm2",             ARCH_AVR4, "__AVR_AT90PWM2__",          0, 0, 0x0100, 1, "90pwm2")
> AVR_MCU ("at90pwm2b",            ARCH_AVR4, "__AVR_AT90PWM2B__",         0, 0, 0x0100, 1, "90pwm2b")
> AVR_MCU ("at90pwm3",             ARCH_AVR4, "__AVR_AT90PWM3__",          0, 0, 0x0100, 1, "90pwm3")
> AVR_MCU ("at90pwm3b",            ARCH_AVR4, "__AVR_AT90PWM3B__",         0, 0, 0x0100, 1, "90pwm3b")
> AVR_MCU ("at90pwm81",            ARCH_AVR4, "__AVR_AT90PWM81__",         0, 0, 0x0100, 1, "90pwm81")
> /* Enhanced, > 8K, <= 64K.  */
> AVR_MCU ("avr5",                 ARCH_AVR5, NULL,                        0, 0, 0x0060, 1, "m16")
> AVR_MCU ("ata5790",              ARCH_AVR5, "__AVR_ATA5790__",           0, 0, 0x0100, 1, "a5790")
> AVR_MCU ("ata5790n",             ARCH_AVR5, "__AVR_ATA5790N__",          0, 0, 0x0100, 1, "a5790n")
> AVR_MCU ("ata5795",              ARCH_AVR5, "__AVR_ATA5795__",           0, 0, 0x0100, 1, "a5795")
> AVR_MCU ("atmega16",             ARCH_AVR5, "__AVR_ATmega16__",          0, 0, 0x0060, 1, "m16")
> AVR_MCU ("atmega16a",            ARCH_AVR5, "__AVR_ATmega16A__",         0, 0, 0x0060, 1, "m16a")
> AVR_MCU ("atmega161",            ARCH_AVR5, "__AVR_ATmega161__",         0, 0, 0x0060, 1, "m161")
> AVR_MCU ("atmega162",            ARCH_AVR5, "__AVR_ATmega162__",         0, 0, 0x0100, 1, "m162")
> AVR_MCU ("atmega163",            ARCH_AVR5, "__AVR_ATmega163__",         0, 0, 0x0060, 1, "m163")
> AVR_MCU ("atmega164a",           ARCH_AVR5, "__AVR_ATmega164A__",        0, 0, 0x0100, 1, "m164a")
> AVR_MCU ("atmega164p",           ARCH_AVR5, "__AVR_ATmega164P__",        0, 0, 0x0100, 1, "m164p")
> AVR_MCU ("atmega164pa",          ARCH_AVR5, "__AVR_ATmega164PA__",       0, 0, 0x0100, 1, "m164pa")
> AVR_MCU ("atmega165",            ARCH_AVR5, "__AVR_ATmega165__",         0, 0, 0x0100, 1, "m165")
> AVR_MCU ("atmega165a",           ARCH_AVR5, "__AVR_ATmega165A__",        0, 0, 0x0100, 1, "m165a")
> AVR_MCU ("atmega165p",           ARCH_AVR5, "__AVR_ATmega165P__",        0, 0, 0x0100, 1, "m165p")
> AVR_MCU ("atmega165pa",          ARCH_AVR5, "__AVR_ATmega165PA__",       0, 0, 0x0100, 1, "m165pa")
> AVR_MCU ("atmega168",            ARCH_AVR5, "__AVR_ATmega168__",         0, 0, 0x0100, 1, "m168")
> AVR_MCU ("atmega168a",           ARCH_AVR5, "__AVR_ATmega168A__",        0, 0, 0x0100, 1, "m168a")
> AVR_MCU ("atmega168p",           ARCH_AVR5, "__AVR_ATmega168P__",        0, 0, 0x0100, 1, "m168p")
> AVR_MCU ("atmega168pa",          ARCH_AVR5, "__AVR_ATmega168PA__",       0, 0, 0x0100, 1, "m168pa")
> AVR_MCU ("atmega169",            ARCH_AVR5, "__AVR_ATmega169__",         0, 0, 0x0100, 1, "m169")
> AVR_MCU ("atmega169a",           ARCH_AVR5, "__AVR_ATmega169A__",        0, 0, 0x0100, 1, "m169a")
> AVR_MCU ("atmega169p",           ARCH_AVR5, "__AVR_ATmega169P__",        0, 0, 0x0100, 1, "m169p")
> AVR_MCU ("atmega169pa",          ARCH_AVR5, "__AVR_ATmega169PA__",       0, 0, 0x0100, 1, "m169pa")
> AVR_MCU ("atmega16hva",          ARCH_AVR5, "__AVR_ATmega16HVA__",       0, 0, 0x0100, 1, "m16hva")
> AVR_MCU ("atmega16hvb",          ARCH_AVR5, "__AVR_ATmega16HVB__",       0, 0, 0x0100, 1, "m16hvb")
> AVR_MCU ("atmega16hvbrevb",      ARCH_AVR5, "__AVR_ATmega16HVBREVB__",   0, 0, 0x0100, 1, "m16hvbrevb")
> AVR_MCU ("atmega16m1",           ARCH_AVR5, "__AVR_ATmega16M1__",        0, 0, 0x0100, 1, "m16m1")
> AVR_MCU ("atmega16u4",           ARCH_AVR5, "__AVR_ATmega16U4__",        0, 0, 0x0100, 1, "m16u4")
> AVR_MCU ("atmega26hvg",          ARCH_AVR5, "__AVR_ATmega26HVG__",       0, 0, 0x0100, 1, "m26hvg")
> AVR_MCU ("atmega32a",            ARCH_AVR5, "__AVR_ATmega32A__",         0, 0, 0x0060, 1, "m32a")
> AVR_MCU ("atmega32",             ARCH_AVR5, "__AVR_ATmega32__",          0, 0, 0x0060, 1, "m32")
> AVR_MCU ("atmega32a",            ARCH_AVR5, "__AVR_ATmega32A__",         0, 0, 0x0060, 1, "m32a")
> AVR_MCU ("atmega323",            ARCH_AVR5, "__AVR_ATmega323__",         0, 0, 0x0060, 1, "m323")
> AVR_MCU ("atmega324a",           ARCH_AVR5, "__AVR_ATmega324A__",        0, 0, 0x0100, 1, "m324a")
> AVR_MCU ("atmega324p",           ARCH_AVR5, "__AVR_ATmega324P__",        0, 0, 0x0100, 1, "m324p")
> AVR_MCU ("atmega324pa",          ARCH_AVR5, "__AVR_ATmega324PA__",       0, 0, 0x0100, 1, "m324pa")
> AVR_MCU ("atmega325",            ARCH_AVR5, "__AVR_ATmega325__",         0, 0, 0x0100, 1, "m325")
> AVR_MCU ("atmega325a",           ARCH_AVR5, "__AVR_ATmega325A__",        0, 0, 0x0100, 1, "m325a")
> AVR_MCU ("atmega325p",           ARCH_AVR5, "__AVR_ATmega325P__",        0, 0, 0x0100, 1, "m325p")
> AVR_MCU ("atmega3250",           ARCH_AVR5, "__AVR_ATmega3250__",        0, 0, 0x0100, 1, "m3250")
> AVR_MCU ("atmega3250a",          ARCH_AVR5, "__AVR_ATmega3250A__",       0, 0, 0x0100, 1, "m3250a")
> AVR_MCU ("atmega3250p",          ARCH_AVR5, "__AVR_ATmega3250P__",       0, 0, 0x0100, 1, "m3250p")
> AVR_MCU ("atmega3250pa",         ARCH_AVR5, "__AVR_ATmega3250PA__",      0, 0, 0x0100, 1, "m3250pa")
> AVR_MCU ("atmega328",            ARCH_AVR5, "__AVR_ATmega328__",         0, 0, 0x0100, 1, "m328")
> AVR_MCU ("atmega328p",           ARCH_AVR5, "__AVR_ATmega328P__",        0, 0, 0x0100, 1, "m328p")
> AVR_MCU ("atmega329",            ARCH_AVR5, "__AVR_ATmega329__",         0, 0, 0x0100, 1, "m329")
> AVR_MCU ("atmega329a",           ARCH_AVR5, "__AVR_ATmega329A__",        0, 0, 0x0100, 1, "m329a")
> AVR_MCU ("atmega329p",           ARCH_AVR5, "__AVR_ATmega329P__",        0, 0, 0x0100, 1, "m329p")
> AVR_MCU ("atmega329pa",          ARCH_AVR5, "__AVR_ATmega329PA__",       0, 0, 0x0100, 1, "m329pa")
> AVR_MCU ("atmega3290",           ARCH_AVR5, "__AVR_ATmega3290__",        0, 0, 0x0100, 1, "m3290")
> AVR_MCU ("atmega3290a",          ARCH_AVR5, "__AVR_ATmega3290A__",       0, 0, 0x0100, 1, "m3290a")
> AVR_MCU ("atmega3290p",          ARCH_AVR5, "__AVR_ATmega3290P__",       0, 0, 0x0100, 1, "m3290p")
> AVR_MCU ("atmega3290pa",         ARCH_AVR5, "__AVR_ATmega3290PA__",      0, 0, 0x0100, 1, "m3290pa")
> AVR_MCU ("atmega32c1",           ARCH_AVR5, "__AVR_ATmega32C1__",        0, 0, 0x0100, 1, "m32c1")
> AVR_MCU ("atmega32m1",           ARCH_AVR5, "__AVR_ATmega32M1__",        0, 0, 0x0100, 1, "m32m1")
> AVR_MCU ("atmega32u4",           ARCH_AVR5, "__AVR_ATmega32U4__",        0, 0, 0x0100, 1, "m32u4")
> AVR_MCU ("atmega32u6",           ARCH_AVR5, "__AVR_ATmega32U6__",        0, 0, 0x0100, 1, "m32u6")
> AVR_MCU ("atmega406",            ARCH_AVR5, "__AVR_ATmega406__",         0, 0, 0x0100, 1, "m406")
> AVR_MCU ("atmega64",             ARCH_AVR5, "__AVR_ATmega64__",          0, 0, 0x0100, 1, "m64")
> AVR_MCU ("atmega64a",            ARCH_AVR5, "__AVR_ATmega64A__",         0, 0, 0x0100, 1, "m64a")
> AVR_MCU ("atmega640",            ARCH_AVR5, "__AVR_ATmega640__",         0, 0, 0x0200, 1, "m640")
> AVR_MCU ("atmega644",            ARCH_AVR5, "__AVR_ATmega644__",         0, 0, 0x0100, 1, "m644")
> AVR_MCU ("atmega644a",           ARCH_AVR5, "__AVR_ATmega644A__",        0, 0, 0x0100, 1, "m644a")
> AVR_MCU ("atmega644p",           ARCH_AVR5, "__AVR_ATmega644P__",        0, 0, 0x0100, 1, "m644p")
> AVR_MCU ("atmega644pa",          ARCH_AVR5, "__AVR_ATmega644PA__",       0, 0, 0x0100, 1, "m644pa")
> AVR_MCU ("atmega645",            ARCH_AVR5, "__AVR_ATmega645__",         0, 0, 0x0100, 1, "m645")
> AVR_MCU ("atmega645a",           ARCH_AVR5, "__AVR_ATmega645A__",        0, 0, 0x0100, 1, "m645a")
> AVR_MCU ("atmega645p",           ARCH_AVR5, "__AVR_ATmega645P__",        0, 0, 0x0100, 1, "m645p")
> AVR_MCU ("atmega6450",           ARCH_AVR5, "__AVR_ATmega6450__",        0, 0, 0x0100, 1, "m6450")
> AVR_MCU ("atmega6450a",          ARCH_AVR5, "__AVR_ATmega6450A__",       0, 0, 0x0100, 1, "m6450a")
> AVR_MCU ("atmega6450p",          ARCH_AVR5, "__AVR_ATmega6450P__",       0, 0, 0x0100, 1, "m6450p")
> AVR_MCU ("atmega649",            ARCH_AVR5, "__AVR_ATmega649__",         0, 0, 0x0100, 1, "m649")
> AVR_MCU ("atmega649a",           ARCH_AVR5, "__AVR_ATmega649A__",        0, 0, 0x0100, 1, "m649a")
> AVR_MCU ("atmega649p",           ARCH_AVR5, "__AVR_ATmega649P__",        0, 0, 0x0100, 1, "m649p")
> AVR_MCU ("atmega6490",           ARCH_AVR5, "__AVR_ATmega6490__",        0, 0, 0x0100, 1, "m6490")
> AVR_MCU ("atmega16hva",          ARCH_AVR5, "__AVR_ATmega16HVA__",       0, 0, 0x0100, 1, "m16hva")
> AVR_MCU ("atmega16hva2",         ARCH_AVR5, "__AVR_ATmega16HVA2__",      0, 0, 0x0100, 1, "m16hva2")
> AVR_MCU ("atmega16hvb",          ARCH_AVR5, "__AVR_ATmega16HVB__",       0, 0, 0x0100, 1, "m16hvb")
> AVR_MCU ("atmega32hvb",          ARCH_AVR5, "__AVR_ATmega32HVB__",       0, 0, 0x0100, 1, "m32hvb")
> AVR_MCU ("atmega6490a",          ARCH_AVR5, "__AVR_ATmega6490A__",       0, 0, 0x0100, 1, "m6490a")
> AVR_MCU ("atmega6490p",          ARCH_AVR5, "__AVR_ATmega6490P__",       0, 0, 0x0100, 1, "m6490p")
> AVR_MCU ("atmega64c1",           ARCH_AVR5, "__AVR_ATmega64C1__",        0, 0, 0x0100, 1, "m64c1")
> AVR_MCU ("atmega64m1",           ARCH_AVR5, "__AVR_ATmega64M1__",        0, 0, 0x0100, 1, "m64m1")
> AVR_MCU ("atmega64hve",          ARCH_AVR5, "__AVR_ATmega64HVE__",       0, 0, 0x0100, 1, "m64hve")
> AVR_MCU ("atmega64rfa2",         ARCH_AVR5, "__AVR_ATmega64RFA2__",      0, 0, 0x0200, 1, "m64rfa2")
> AVR_MCU ("atmega64rfr2",         ARCH_AVR5, "__AVR_ATmega64RFR2__",      0, 0, 0x0200, 1, "m64rfr2")
> AVR_MCU ("atmega32hvb",          ARCH_AVR5, "__AVR_ATmega32HVB__",       0, 0, 0x0100, 1, "m32hvb")
> AVR_MCU ("atmega32hvbrevb",      ARCH_AVR5, "__AVR_ATmega32HVBREVB__",   0, 0, 0x0100, 1, "m32hvbrevb")
> AVR_MCU ("atmega16hva2",         ARCH_AVR5, "__AVR_ATmega16HVA2__",      0, 0, 0x0100, 1, "m16hva2")
> AVR_MCU ("atmega48hvf",          ARCH_AVR5, "__AVR_ATmega48HVF__",       0, 0, 0x0100, 1, "m48hvf")
> AVR_MCU ("at90can32",            ARCH_AVR5, "__AVR_AT90CAN32__",         0, 0, 0x0100, 1, "can32")
> AVR_MCU ("at90can64",            ARCH_AVR5, "__AVR_AT90CAN64__",         0, 0, 0x0100, 1, "can64")
> AVR_MCU ("at90pwm161",           ARCH_AVR5, "__AVR_AT90PWM161__",        0, 0, 0x0100, 1, "90pwm161")
> AVR_MCU ("at90pwm216",           ARCH_AVR5, "__AVR_AT90PWM216__",        0, 0, 0x0100, 1, "90pwm216")
> AVR_MCU ("at90pwm316",           ARCH_AVR5, "__AVR_AT90PWM316__",        0, 0, 0x0100, 1, "90pwm316")
> AVR_MCU ("atmega32c1",           ARCH_AVR5, "__AVR_ATmega32C1__",        0, 0, 0x0100, 1, "m32c1")
> AVR_MCU ("atmega64c1",           ARCH_AVR5, "__AVR_ATmega64C1__",        0, 0, 0x0100, 1, "m64c1")
> AVR_MCU ("atmega16m1",           ARCH_AVR5, "__AVR_ATmega16M1__",        0, 0, 0x0100, 1, "m16m1")
> AVR_MCU ("atmega32m1",           ARCH_AVR5, "__AVR_ATmega32M1__",        0, 0, 0x0100, 1, "m32m1")
> AVR_MCU ("atmega64m1",           ARCH_AVR5, "__AVR_ATmega64M1__",        0, 0, 0x0100, 1, "m64m1")
> AVR_MCU ("atmega16u4",           ARCH_AVR5, "__AVR_ATmega16U4__",        0, 0, 0x0100, 1, "m16u4")
> AVR_MCU ("atmega32u4",           ARCH_AVR5, "__AVR_ATmega32U4__",        0, 0, 0x0100, 1, "m32u4")
> AVR_MCU ("atmega32u6",           ARCH_AVR5, "__AVR_ATmega32U6__",        0, 0, 0x0100, 1, "m32u6")
> AVR_MCU ("at90scr100",           ARCH_AVR5, "__AVR_AT90SCR100__",        0, 0, 0x0100, 1, "90scr100")
> AVR_MCU ("at90usb646",           ARCH_AVR5, "__AVR_AT90USB646__",        0, 0, 0x0100, 1, "usb646")
> AVR_MCU ("at90usb647",           ARCH_AVR5, "__AVR_AT90USB647__",        0, 0, 0x0100, 1, "usb647")
> AVR_MCU ("at94k",                ARCH_AVR5, "__AVR_AT94K__",             0, 0, 0x0060, 1, "at94k")
> AVR_MCU ("m3000",                ARCH_AVR5, "__AVR_M3000__",             0, 0, 0x1000, 1, "m3000")
> /* Enhanced, == 128K.  */
> AVR_MCU ("avr51",                ARCH_AVR51, NULL,                       0, 0, 0x0100, 2, "m128")
> AVR_MCU ("atmega128",            ARCH_AVR51, "__AVR_ATmega128__",        0, 0, 0x0100, 2, "m128")
> AVR_MCU ("atmega128a",           ARCH_AVR51, "__AVR_ATmega128A__",       0, 0, 0x0100, 2, "m128a")
> AVR_MCU ("atmega1280",           ARCH_AVR51, "__AVR_ATmega1280__",       0, 0, 0x0200, 2, "m1280")
> AVR_MCU ("atmega1281",           ARCH_AVR51, "__AVR_ATmega1281__",       0, 0, 0x0200, 2, "m1281")
> AVR_MCU ("atmega1284",           ARCH_AVR51, "__AVR_ATmega1284__",       0, 0, 0x0100, 2, "m1284")
> AVR_MCU ("atmega1284p",          ARCH_AVR51, "__AVR_ATmega1284P__",      0, 0, 0x0100, 2, "m1284p")
> AVR_MCU ("atmega128rfa1",        ARCH_AVR51, "__AVR_ATmega128RFA1__",    0, 0, 0x0200, 2, "m128rfa1")
> AVR_MCU ("at90can128",           ARCH_AVR51, "__AVR_AT90CAN128__",       0, 0, 0x0100, 2, "can128")
> AVR_MCU ("at90usb1286",          ARCH_AVR51, "__AVR_AT90USB1286__",      0, 0, 0x0100, 2, "usb1286")
> AVR_MCU ("at90usb1287",          ARCH_AVR51, "__AVR_AT90USB1287__",      0, 0, 0x0100, 2, "usb1287")
> /* 3-Byte PC.  */
> AVR_MCU ("avr6",                 ARCH_AVR6, NULL,                        0, 0, 0x0200, 4, "m2561")
> AVR_MCU ("atmega2560",           ARCH_AVR6, "__AVR_ATmega2560__",        0, 0, 0x0200, 4, "m2560")
> AVR_MCU ("atmega2561",           ARCH_AVR6, "__AVR_ATmega2561__",        0, 0, 0x0200, 4, "m2561")
278,291c273,288
< AVR_MCU ("avrxmega2",        ARCH_AVRXMEGA2, AVR_ISA_NONE, NULL,                       0x2000, 0x0, 1, "x32a4")
< AVR_MCU ("atxmega8e5",       ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega8E5__",       0x2000, 0x0, 1, "x8e5")
< AVR_MCU ("atxmega16a4",      ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega16A4__",      0x2000, 0x0, 1, "x16a4")
< AVR_MCU ("atxmega16a4u",     ARCH_AVRXMEGA2, AVR_ISA_RMW,  "__AVR_ATxmega16A4U__",     0x2000, 0x0, 1, "x16a4u")
< AVR_MCU ("atxmega16c4",      ARCH_AVRXMEGA2, AVR_ISA_RMW,  "__AVR_ATxmega16C4__",      0x2000, 0x0, 1, "x16c4")
< AVR_MCU ("atxmega16d4",      ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega16D4__",      0x2000, 0x0, 1, "x16d4")
< AVR_MCU ("atxmega16e5",      ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega16E5__",      0x2000, 0x0, 1, "x16e5")
< AVR_MCU ("atxmega32a4",      ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega32A4__",      0x2000, 0x0, 1, "x32a4")
< AVR_MCU ("atxmega32a4u",     ARCH_AVRXMEGA2, AVR_ISA_RMW,  "__AVR_ATxmega32A4U__",     0x2000, 0x0, 1, "x32a4u")
< AVR_MCU ("atxmega32c3",      ARCH_AVRXMEGA2, AVR_ISA_RMW,  "__AVR_ATxmega32C3__",      0x2000, 0x0, 1, "x32c3")
< AVR_MCU ("atxmega32c4",      ARCH_AVRXMEGA2, AVR_ISA_RMW,  "__AVR_ATxmega32C4__",      0x2000, 0x0, 1, "x32c4")
< AVR_MCU ("atxmega32d3",      ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega32D3__",      0x2000, 0x0, 1, "x32d3")
< AVR_MCU ("atxmega32d4",      ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega32D4__",      0x2000, 0x0, 1, "x32d4")
< AVR_MCU ("atxmega32e5",      ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega32E5__",      0x2000, 0x0, 1, "x32e5")
---
> AVR_MCU ("avrxmega2",        ARCH_AVRXMEGA2, NULL,                       0, 0, 0x2000, 1, "x32a4")
> AVR_MCU ("atxmega16a4",      ARCH_AVRXMEGA2, "__AVR_ATxmega16A4__",      0, 0, 0x2000, 1, "x16a4")
> AVR_MCU ("atxmega16d4",      ARCH_AVRXMEGA2, "__AVR_ATxmega16D4__",      0, 0, 0x2000, 1, "x16d4")
> AVR_MCU ("atxmega16x1",      ARCH_AVRXMEGA2, "__AVR_ATxmega16X1__",      0, 0, 0x2000, 1, "x16x1")
> AVR_MCU ("atxmega32a4",      ARCH_AVRXMEGA2, "__AVR_ATxmega32A4__",      0, 0, 0x2000, 1, "x32a4")
> AVR_MCU ("atxmega32d4",      ARCH_AVRXMEGA2, "__AVR_ATxmega32D4__",      0, 0, 0x2000, 1, "x32d4")
> AVR_MCU ("atxmega32x1",      ARCH_AVRXMEGA2, "__AVR_ATxmega32X1__",      0, 0, 0x2000, 1, "x32x1")
> AVR_MCU ("atmxt112sl",       ARCH_AVRXMEGA2, "__AVR_ATMXT112SL__",       0, 0, 0x2000, 1, "mxt112sl")
> AVR_MCU ("atmxt224",         ARCH_AVRXMEGA2, "__AVR_ATMXT224__",         0, 0, 0x2000, 1, "mxt224")
> AVR_MCU ("atmxt224e",        ARCH_AVRXMEGA2, "__AVR_ATMXT224E__",        0, 0, 0x2000, 1, "mxt224e")
> AVR_MCU ("atmxt336s",        ARCH_AVRXMEGA2, "__AVR_ATMXT336S__",        0, 0, 0x2000, 1, "mxt336s")
> AVR_MCU ("atxmega16a4u",     ARCH_AVRXMEGA2, "__AVR_ATxmega16A4U__",     0, 0, 0x2000, 1, "x16a4u")
> AVR_MCU ("atxmega16c4",      ARCH_AVRXMEGA2, "__AVR_ATxmega16C4__",      0, 0, 0x2000, 1, "x16c4")
> AVR_MCU ("atxmega32a4u",     ARCH_AVRXMEGA2, "__AVR_ATxmega32A4U__",     0, 0, 0x2000, 1, "x32a4u")
> AVR_MCU ("atxmega32c4",      ARCH_AVRXMEGA2, "__AVR_ATxmega32C4__",      0, 0, 0x2000, 1, "x32c4")
> AVR_MCU ("atxmega32e5",      ARCH_AVRXMEGA2, "__AVR_ATxmega32E5__",      0, 0, 0x2000, 1, "x32e5")
293,301c290,298
< AVR_MCU ("avrxmega4",        ARCH_AVRXMEGA4, AVR_ISA_NONE, NULL,                       0x2000, 0x0, 2, "x64a4")
< AVR_MCU ("atxmega64a3",      ARCH_AVRXMEGA4, AVR_ISA_NONE, "__AVR_ATxmega64A3__",      0x2000, 0x0, 2, "x64a3")
< AVR_MCU ("atxmega64a3u",     ARCH_AVRXMEGA4, AVR_ISA_RMW,  "__AVR_ATxmega64A3U__",     0x2000, 0x0, 2, "x64a3u")
< AVR_MCU ("atxmega64a4u",     ARCH_AVRXMEGA4, AVR_ISA_RMW,  "__AVR_ATxmega64A4U__",     0x2000, 0x0, 2, "x64a4u")
< AVR_MCU ("atxmega64b1",      ARCH_AVRXMEGA4, AVR_ISA_RMW,  "__AVR_ATxmega64B1__",      0x2000, 0x0, 2, "x64b1")
< AVR_MCU ("atxmega64b3",      ARCH_AVRXMEGA4, AVR_ISA_RMW,  "__AVR_ATxmega64B3__",      0x2000, 0x0, 2, "x64b3")
< AVR_MCU ("atxmega64c3",      ARCH_AVRXMEGA4, AVR_ISA_RMW,  "__AVR_ATxmega64C3__",      0x2000, 0x0, 2, "x64c3")
< AVR_MCU ("atxmega64d3",      ARCH_AVRXMEGA4, AVR_ISA_NONE, "__AVR_ATxmega64D3__",      0x2000, 0x0, 2, "x64d3")
< AVR_MCU ("atxmega64d4",      ARCH_AVRXMEGA4, AVR_ISA_NONE, "__AVR_ATxmega64D4__",      0x2000, 0x0, 2, "x64d4")
---
> AVR_MCU ("avrxmega4",        ARCH_AVRXMEGA4, NULL,                       0, 0, 0x2000, 2, "x64a4")
> AVR_MCU ("atxmega64a3",      ARCH_AVRXMEGA4, "__AVR_ATxmega64A3__",      0, 0, 0x2000, 2, "x64a3")
> AVR_MCU ("atxmega64d3",      ARCH_AVRXMEGA4, "__AVR_ATxmega64D3__",      0, 0, 0x2000, 2, "x64d3")
> AVR_MCU ("atxmega64a3u",     ARCH_AVRXMEGA4, "__AVR_ATxmega64A3U__",     0, 0, 0x2000, 2, "x64a3u")
> AVR_MCU ("atxmega64a4u",     ARCH_AVRXMEGA4, "__AVR_ATxmega64A4U__",     0, 0, 0x2000, 2, "x64a4u")
> AVR_MCU ("atxmega64b1",      ARCH_AVRXMEGA4, "__AVR_ATxmega64B1__",      0, 0, 0x2000, 2, "x64b1")
> AVR_MCU ("atxmega64b3",      ARCH_AVRXMEGA4, "__AVR_ATxmega64B3__",      0, 0, 0x2000, 2, "x64b3")
> AVR_MCU ("atxmega64c3",      ARCH_AVRXMEGA4, "__AVR_ATxmega64C3__",      0, 0, 0x2000, 2, "x64c3")
> AVR_MCU ("atxmega64d4",      ARCH_AVRXMEGA4, "__AVR_ATxmega64D4__",      0, 0, 0x2000, 2, "x64d4")
303,305c300,302
< AVR_MCU ("avrxmega5",        ARCH_AVRXMEGA5, AVR_ISA_NONE, NULL,                       0x2000, 0x0, 2, "x64a1")
< AVR_MCU ("atxmega64a1",      ARCH_AVRXMEGA5, AVR_ISA_NONE, "__AVR_ATxmega64A1__",      0x2000, 0x0, 2, "x64a1")
< AVR_MCU ("atxmega64a1u",     ARCH_AVRXMEGA5, AVR_ISA_RMW,  "__AVR_ATxmega64A1U__",     0x2000, 0x0, 2, "x64a1u")
---
> AVR_MCU ("avrxmega5",        ARCH_AVRXMEGA5, NULL,                       0, 0, 0x2000, 2, "x64a1")
> AVR_MCU ("atxmega64a1",      ARCH_AVRXMEGA5, "__AVR_ATxmega64A1__",      0, 0, 0x2000, 2, "x64a1")
> AVR_MCU ("atxmega64a1u",     ARCH_AVRXMEGA5, "__AVR_ATxmega64A1U__",     0, 0, 0x2000, 2, "x64a1u")
307,339c304,330
< AVR_MCU ("avrxmega6",        ARCH_AVRXMEGA6, AVR_ISA_NONE, NULL,                       0x2000, 0x0, 6, "x128a3")
< AVR_MCU ("atxmega128a3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega128A3__",     0x2000, 0x0, 3, "x128a3")
< AVR_MCU ("atxmega128a3u",    ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega128A3U__",    0x2000, 0x0, 3, "x128a3u")
< AVR_MCU ("atxmega128b1",     ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega128B1__",     0x2000, 0x0, 3, "x128b1")
< AVR_MCU ("atxmega128b3",     ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega128B3__",     0x2000, 0x0, 3, "x128b3")
< AVR_MCU ("atxmega128c3",     ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega128C3__",     0x2000, 0x0, 3, "x128c3")
< AVR_MCU ("atxmega128d3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega128D3__",     0x2000, 0x0, 3, "x128d3")
< AVR_MCU ("atxmega128d4",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega128D4__",     0x2000, 0x0, 3, "x128d4")
< AVR_MCU ("atxmega192a3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega192A3__",     0x2000, 0x0, 4, "x192a3")
< AVR_MCU ("atxmega192a3u",    ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega192A3U__",    0x2000, 0x0, 4, "x192a3u")
< AVR_MCU ("atxmega192c3",     ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega192C3__",     0x2000, 0x0, 4, "x192c3")
< AVR_MCU ("atxmega192d3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega192D3__",     0x2000, 0x0, 4, "x192d3")
< AVR_MCU ("atxmega256a3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega256A3__",     0x2000, 0x0, 5, "x256a3")
< AVR_MCU ("atxmega256a3b",    ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega256A3B__",    0x2000, 0x0, 5, "x256a3b")
< AVR_MCU ("atxmega256a3bu",   ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega256A3BU__",   0x2000, 0x0, 5, "x256a3bu")
< AVR_MCU ("atxmega256a3u",    ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega256A3U__",    0x2000, 0x0, 5, "x256a3u")
< AVR_MCU ("atxmega256c3",     ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega256C3__",     0x2000, 0x0, 5, "x256c3")
< AVR_MCU ("atxmega256d3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega256D3__",     0x2000, 0x0, 5, "x256d3")
< AVR_MCU ("atxmega384c3",     ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega384C3__",     0x2000, 0x0, 6, "x384c3")
< AVR_MCU ("atxmega384d3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega384D3__",     0x2000, 0x0, 6, "x384d3")
< /* Xmega, >= 128K, <= 256K FLASH, > 64K RAM.  */
< AVR_MCU ("avrxmega7",        ARCH_AVRXMEGA7, AVR_ISA_NONE, NULL,                       0x2000, 0x0, 3, "x128a1")
< AVR_MCU ("atxmega128a1",     ARCH_AVRXMEGA7, AVR_ISA_NONE, "__AVR_ATxmega128A1__",     0x2000, 0x0, 3, "x128a1")
< AVR_MCU ("atxmega128a1u",    ARCH_AVRXMEGA7, AVR_ISA_RMW,  "__AVR_ATxmega128A1U__",    0x2000, 0x0, 3, "x128a1u")
< AVR_MCU ("atxmega128a4u",    ARCH_AVRXMEGA7, AVR_ISA_RMW,  "__AVR_ATxmega128A4U__",    0x2000, 0x0, 3, "x128a4u")
< /* Tiny family */
< AVR_MCU ("avrtiny",          ARCH_AVRTINY, AVR_ISA_NONE,   NULL,                       0x0040, 0x0, 1, "tn10")
< AVR_MCU ("attiny4",          ARCH_AVRTINY, AVR_ISA_NONE,   "__AVR_ATtiny4__",          0x0040, 0x0, 1, "tn4")
< AVR_MCU ("attiny5",          ARCH_AVRTINY, AVR_ISA_NONE,   "__AVR_ATtiny5__",          0x0040, 0x0, 1, "tn5")
< AVR_MCU ("attiny9",          ARCH_AVRTINY, AVR_ISA_NONE,   "__AVR_ATtiny9__",          0x0040, 0x0, 1, "tn9") 
< AVR_MCU ("attiny10",         ARCH_AVRTINY, AVR_ISA_NONE,   "__AVR_ATtiny10__",         0x0040, 0x0, 1, "tn10")
< AVR_MCU ("attiny20",         ARCH_AVRTINY, AVR_ISA_NONE,   "__AVR_ATtiny20__",         0x0040, 0x0, 1, "tn20")
< AVR_MCU ("attiny40",         ARCH_AVRTINY, AVR_ISA_NONE,   "__AVR_ATtiny40__",         0x0040, 0x0, 1, "tn40")
---
> AVR_MCU ("avrxmega6",        ARCH_AVRXMEGA6, NULL,                       0, 0, 0x2000, 6, "x128a3")
> AVR_MCU ("atxmega128a3",     ARCH_AVRXMEGA6, "__AVR_ATxmega128A3__",     0, 0, 0x2000, 3, "x128a3")
> AVR_MCU ("atxmega128d3",     ARCH_AVRXMEGA6, "__AVR_ATxmega128D3__",     0, 0, 0x2000, 3, "x128d3")
> AVR_MCU ("atxmega192a3",     ARCH_AVRXMEGA6, "__AVR_ATxmega192A3__",     0, 0, 0x2000, 4, "x192a3")
> AVR_MCU ("atxmega192d3",     ARCH_AVRXMEGA6, "__AVR_ATxmega192D3__",     0, 0, 0x2000, 4, "x192d3")
> AVR_MCU ("atxmega256a3",     ARCH_AVRXMEGA6, "__AVR_ATxmega256A3__",     0, 0, 0x2000, 5, "x256a3")
> AVR_MCU ("atxmega256a3b",    ARCH_AVRXMEGA6, "__AVR_ATxmega256A3B__",    0, 0, 0x2000, 5, "x256a3b")
> AVR_MCU ("atxmega256a3bu",   ARCH_AVRXMEGA6, "__AVR_ATxmega256A3BU__",   0, 0, 0x2000, 5, "x256a3bu")
> AVR_MCU ("atxmega256d3",     ARCH_AVRXMEGA6, "__AVR_ATxmega256D3__",     0, 0, 0x2000, 5, "x256d3")
> AVR_MCU ("atxmega128a3u",    ARCH_AVRXMEGA6, "__AVR_ATxmega128A3U__",    0, 0, 0x2000, 3, "x128a3u")
> AVR_MCU ("atxmega128b1",     ARCH_AVRXMEGA6, "__AVR_ATxmega128B1__",     0, 0, 0x2000, 3, "x128b1")
> AVR_MCU ("atxmega128b3",     ARCH_AVRXMEGA6, "__AVR_ATxmega128B3__",     0, 0, 0x2000, 3, "x128b3")
> AVR_MCU ("atxmega128c3",     ARCH_AVRXMEGA6, "__AVR_ATxmega128C3__",     0, 0, 0x2000, 3, "x128c3")
> AVR_MCU ("atxmega128d4",     ARCH_AVRXMEGA6, "__AVR_ATxmega128D4__",     0, 0, 0x2000, 3, "x128d4")
> AVR_MCU ("atmxt540s",        ARCH_AVRXMEGA6, "__AVR_ATMXT540S__",        0, 0, 0x2000, 2, "mxt540s")
> AVR_MCU ("atmxt540sreva",    ARCH_AVRXMEGA6, "__AVR_ATMXT540SREVA__",    0, 0, 0x2000, 2, "mxt540sreva")
> AVR_MCU ("atxmega192a3u",    ARCH_AVRXMEGA6, "__AVR_ATxmega192A3U__",    0, 0, 0x2000, 4, "x192a3u")
> AVR_MCU ("atxmega192c3",     ARCH_AVRXMEGA6, "__AVR_ATxmega192C3__",     0, 0, 0x2000, 4, "x192c3")
> AVR_MCU ("atxmega256a3u",    ARCH_AVRXMEGA6, "__AVR_ATxmega256A3U__",    0, 0, 0x2000, 5, "x256a3u")
> AVR_MCU ("atxmega256c3",     ARCH_AVRXMEGA6, "__AVR_ATxmega256C3__",     0, 0, 0x2000, 5, "x256c3")
> AVR_MCU ("atxmega384c3",     ARCH_AVRXMEGA6, "__AVR_ATxmega384C3__",     0, 0, 0x2000, 6, "x384c3")
> AVR_MCU ("atxmega384d3",     ARCH_AVRXMEGA6, "__AVR_ATxmega384D3__",     0, 0, 0x2000, 6, "x384d3")
> /* Xmega, 128K < Flash, RAM > 64K RAM.  */
> AVR_MCU ("avrxmega7",        ARCH_AVRXMEGA7, NULL,                       0, 0, 0x2000, 3, "x128a1")
> AVR_MCU ("atxmega128a1",     ARCH_AVRXMEGA7, "__AVR_ATxmega128A1__",     0, 0, 0x2000, 3, "x128a1")
> AVR_MCU ("atxmega128a1u",    ARCH_AVRXMEGA7, "__AVR_ATxmega128A1U__",    0, 0, 0x2000, 3, "x128a1u")
> AVR_MCU ("atxmega128a4u",    ARCH_AVRXMEGA7, "__AVR_ATxmega128A4U__",    0, 0, 0x2000, 3, "x128a4u")
341,346c332,337
< AVR_MCU ("avr1",                 ARCH_AVR1, AVR_ISA_NONE, NULL,                        0x0060, 0x0, 1, "s1200")
< AVR_MCU ("at90s1200",            ARCH_AVR1, AVR_ISA_NONE, "__AVR_AT90S1200__",         0x0060, 0x0, 1, "s1200")
< AVR_MCU ("attiny11",             ARCH_AVR1, AVR_ISA_NONE, "__AVR_ATtiny11__",          0x0060, 0x0, 1, "tn11")
< AVR_MCU ("attiny12",             ARCH_AVR1, AVR_ISA_NONE, "__AVR_ATtiny12__",          0x0060, 0x0, 1, "tn12")
< AVR_MCU ("attiny15",             ARCH_AVR1, AVR_ISA_NONE, "__AVR_ATtiny15__",          0x0060, 0x0, 1, "tn15")
< AVR_MCU ("attiny28",             ARCH_AVR1, AVR_ISA_NONE, "__AVR_ATtiny28__",          0x0060, 0x0, 1, "tn28")
---
> AVR_MCU ("avr1",                 ARCH_AVR1, NULL,                        0, 0, 0x0060, 1, "s1200")
> AVR_MCU ("at90s1200",            ARCH_AVR1, "__AVR_AT90S1200__",         0, 0, 0x0060, 1, "s1200")
> AVR_MCU ("attiny11",             ARCH_AVR1, "__AVR_ATtiny11__",          0, 0, 0x0060, 1, "tn11")
> AVR_MCU ("attiny12",             ARCH_AVR1, "__AVR_ATtiny12__",          0, 0, 0x0060, 1, "tn12")
> AVR_MCU ("attiny15",             ARCH_AVR1, "__AVR_ATtiny15__",          0, 0, 0x0060, 1, "tn15")
> AVR_MCU ("attiny28",             ARCH_AVR1, "__AVR_ATtiny28__",          0, 0, 0x0060, 1, "tn28")
diff -r avr/gcc/config/avr/avr-protos.h gcc/gcc/config/avr/avr-protos.h
48d47
< extern bool tiny_valid_direct_memory_access_range(rtx, enum machine_mode);
90,91c89
< extern const char* avr_out_plus (rtx, rtx*, int* =NULL, int* =NULL, bool =true);
< extern const char* avr_out_round (rtx, rtx*, int* =NULL);
---
> extern const char* avr_out_plus (rtx, rtx*, int* =NULL, int* =NULL);
diff -r avr/gcc/config/avr/avr-stdint.h gcc/gcc/config/avr/avr-stdint.h
37c37
< #define INT16_TYPE (INT_TYPE_SIZE == 16 ? "int" : "long int")
---
> #define INT16_TYPE (INT_TYPE_SIZE == 16 ? "short int" : "long int")
41c41
< #define UINT16_TYPE (INT_TYPE_SIZE == 16 ? "unsigned int" : "long unsigned int")
---
> #define UINT16_TYPE (INT_TYPE_SIZE == 16 ? "short unsigned int" : "long unsigned int")
diff -r avr/gcc/config/avr/avr-tables.opt gcc/gcc/config/avr/avr-tables.opt
69c69
< Enum(avr_mcu) String(ata5272) Value(14)
---
> Enum(avr_mcu) String(ata6289) Value(14)
72c72
< Enum(avr_mcu) String(ata6616c) Value(15)
---
> Enum(avr_mcu) String(ata5272) Value(15)
102c102
< Enum(avr_mcu) String(attiny441) Value(25)
---
> Enum(avr_mcu) String(attiny84) Value(25)
105c105
< Enum(avr_mcu) String(attiny84) Value(26)
---
> Enum(avr_mcu) String(attiny84a) Value(26)
108c108
< Enum(avr_mcu) String(attiny84a) Value(27)
---
> Enum(avr_mcu) String(attiny25) Value(27)
111c111
< Enum(avr_mcu) String(attiny25) Value(28)
---
> Enum(avr_mcu) String(attiny45) Value(28)
114c114
< Enum(avr_mcu) String(attiny45) Value(29)
---
> Enum(avr_mcu) String(attiny85) Value(29)
117c117
< Enum(avr_mcu) String(attiny85) Value(30)
---
> Enum(avr_mcu) String(attiny261) Value(30)
120c120
< Enum(avr_mcu) String(attiny261) Value(31)
---
> Enum(avr_mcu) String(attiny261a) Value(31)
123c123
< Enum(avr_mcu) String(attiny261a) Value(32)
---
> Enum(avr_mcu) String(attiny461) Value(32)
126c126
< Enum(avr_mcu) String(attiny461) Value(33)
---
> Enum(avr_mcu) String(attiny461a) Value(33)
129c129
< Enum(avr_mcu) String(attiny461a) Value(34)
---
> Enum(avr_mcu) String(attiny861) Value(34)
132c132
< Enum(avr_mcu) String(attiny861) Value(35)
---
> Enum(avr_mcu) String(attiny861a) Value(35)
135c135
< Enum(avr_mcu) String(attiny861a) Value(36)
---
> Enum(avr_mcu) String(attiny43u) Value(36)
138c138
< Enum(avr_mcu) String(attiny43u) Value(37)
---
> Enum(avr_mcu) String(attiny87) Value(37)
141c141
< Enum(avr_mcu) String(attiny87) Value(38)
---
> Enum(avr_mcu) String(attiny48) Value(38)
144c144
< Enum(avr_mcu) String(attiny48) Value(39)
---
> Enum(avr_mcu) String(attiny88) Value(39)
147c147
< Enum(avr_mcu) String(attiny88) Value(40)
---
> Enum(avr_mcu) String(at86rf401) Value(40)
150c150
< Enum(avr_mcu) String(attiny828) Value(41)
---
> Enum(avr_mcu) String(avr3) Value(41)
153c153
< Enum(avr_mcu) String(attiny841) Value(42)
---
> Enum(avr_mcu) String(at43usb355) Value(42)
156c156
< Enum(avr_mcu) String(at86rf401) Value(43)
---
> Enum(avr_mcu) String(at76c711) Value(43)
159c159
< Enum(avr_mcu) String(avr3) Value(44)
---
> Enum(avr_mcu) String(avr31) Value(44)
162c162
< Enum(avr_mcu) String(at43usb355) Value(45)
---
> Enum(avr_mcu) String(atmega103) Value(45)
165c165
< Enum(avr_mcu) String(at76c711) Value(46)
---
> Enum(avr_mcu) String(at43usb320) Value(46)
168c168
< Enum(avr_mcu) String(avr31) Value(47)
---
> Enum(avr_mcu) String(avr35) Value(47)
171c171
< Enum(avr_mcu) String(atmega103) Value(48)
---
> Enum(avr_mcu) String(ata5505) Value(48)
174c174
< Enum(avr_mcu) String(at43usb320) Value(49)
---
> Enum(avr_mcu) String(at90usb82) Value(49)
177c177
< Enum(avr_mcu) String(avr35) Value(50)
---
> Enum(avr_mcu) String(at90usb162) Value(50)
180c180
< Enum(avr_mcu) String(ata5505) Value(51)
---
> Enum(avr_mcu) String(atmega8u2) Value(51)
183c183
< Enum(avr_mcu) String(ata6617c) Value(52)
---
> Enum(avr_mcu) String(atmega16u2) Value(52)
186c186
< Enum(avr_mcu) String(ata664251) Value(53)
---
> Enum(avr_mcu) String(atmega32u2) Value(53)
189c189
< Enum(avr_mcu) String(at90usb82) Value(54)
---
> Enum(avr_mcu) String(attiny167) Value(54)
192c192
< Enum(avr_mcu) String(at90usb162) Value(55)
---
> Enum(avr_mcu) String(attiny1634) Value(55)
195c195
< Enum(avr_mcu) String(atmega8u2) Value(56)
---
> Enum(avr_mcu) String(avr4) Value(56)
198c198
< Enum(avr_mcu) String(atmega16u2) Value(57)
---
> Enum(avr_mcu) String(ata6285) Value(57)
201c201
< Enum(avr_mcu) String(atmega32u2) Value(58)
---
> Enum(avr_mcu) String(ata6286) Value(58)
204c204
< Enum(avr_mcu) String(attiny167) Value(59)
---
> Enum(avr_mcu) String(atmega8) Value(59)
207c207
< Enum(avr_mcu) String(attiny1634) Value(60)
---
> Enum(avr_mcu) String(atmega8a) Value(60)
210c210
< Enum(avr_mcu) String(avr4) Value(61)
---
> Enum(avr_mcu) String(atmega48) Value(61)
213c213
< Enum(avr_mcu) String(ata6285) Value(62)
---
> Enum(avr_mcu) String(atmega48a) Value(62)
216c216
< Enum(avr_mcu) String(ata6286) Value(63)
---
> Enum(avr_mcu) String(atmega48p) Value(63)
219c219
< Enum(avr_mcu) String(ata6289) Value(64)
---
> Enum(avr_mcu) String(atmega48pa) Value(64)
222c222
< Enum(avr_mcu) String(ata6612c) Value(65)
---
> Enum(avr_mcu) String(atmega88) Value(65)
225c225
< Enum(avr_mcu) String(atmega8) Value(66)
---
> Enum(avr_mcu) String(atmega88a) Value(66)
228c228
< Enum(avr_mcu) String(atmega8a) Value(67)
---
> Enum(avr_mcu) String(atmega88p) Value(67)
231c231
< Enum(avr_mcu) String(atmega48) Value(68)
---
> Enum(avr_mcu) String(atmega88pa) Value(68)
234c234
< Enum(avr_mcu) String(atmega48a) Value(69)
---
> Enum(avr_mcu) String(atmega8515) Value(69)
237c237
< Enum(avr_mcu) String(atmega48p) Value(70)
---
> Enum(avr_mcu) String(atmega8535) Value(70)
240c240
< Enum(avr_mcu) String(atmega48pa) Value(71)
---
> Enum(avr_mcu) String(atmega8hva) Value(71)
243c243
< Enum(avr_mcu) String(atmega48pb) Value(72)
---
> Enum(avr_mcu) String(at90pwm1) Value(72)
246c246
< Enum(avr_mcu) String(atmega88) Value(73)
---
> Enum(avr_mcu) String(at90pwm2) Value(73)
249c249
< Enum(avr_mcu) String(atmega88a) Value(74)
---
> Enum(avr_mcu) String(at90pwm2b) Value(74)
252c252
< Enum(avr_mcu) String(atmega88p) Value(75)
---
> Enum(avr_mcu) String(at90pwm3) Value(75)
255c255
< Enum(avr_mcu) String(atmega88pa) Value(76)
---
> Enum(avr_mcu) String(at90pwm3b) Value(76)
258c258
< Enum(avr_mcu) String(atmega88pb) Value(77)
---
> Enum(avr_mcu) String(at90pwm81) Value(77)
261c261
< Enum(avr_mcu) String(atmega8515) Value(78)
---
> Enum(avr_mcu) String(avr5) Value(78)
264c264
< Enum(avr_mcu) String(atmega8535) Value(79)
---
> Enum(avr_mcu) String(ata5790) Value(79)
267c267
< Enum(avr_mcu) String(atmega8hva) Value(80)
---
> Enum(avr_mcu) String(ata5790n) Value(80)
270c270
< Enum(avr_mcu) String(at90pwm1) Value(81)
---
> Enum(avr_mcu) String(ata5795) Value(81)
273c273
< Enum(avr_mcu) String(at90pwm2) Value(82)
---
> Enum(avr_mcu) String(atmega16) Value(82)
276c276
< Enum(avr_mcu) String(at90pwm2b) Value(83)
---
> Enum(avr_mcu) String(atmega16a) Value(83)
279c279
< Enum(avr_mcu) String(at90pwm3) Value(84)
---
> Enum(avr_mcu) String(atmega161) Value(84)
282c282
< Enum(avr_mcu) String(at90pwm3b) Value(85)
---
> Enum(avr_mcu) String(atmega162) Value(85)
285c285
< Enum(avr_mcu) String(at90pwm81) Value(86)
---
> Enum(avr_mcu) String(atmega163) Value(86)
288c288
< Enum(avr_mcu) String(avr5) Value(87)
---
> Enum(avr_mcu) String(atmega164a) Value(87)
291c291
< Enum(avr_mcu) String(ata5702m322) Value(88)
---
> Enum(avr_mcu) String(atmega164p) Value(88)
294c294
< Enum(avr_mcu) String(ata5782) Value(89)
---
> Enum(avr_mcu) String(atmega164pa) Value(89)
297c297
< Enum(avr_mcu) String(ata5790) Value(90)
---
> Enum(avr_mcu) String(atmega165) Value(90)
300c300
< Enum(avr_mcu) String(ata5790n) Value(91)
---
> Enum(avr_mcu) String(atmega165a) Value(91)
303c303
< Enum(avr_mcu) String(ata5795) Value(92)
---
> Enum(avr_mcu) String(atmega165p) Value(92)
306c306
< Enum(avr_mcu) String(ata5831) Value(93)
---
> Enum(avr_mcu) String(atmega165pa) Value(93)
309c309
< Enum(avr_mcu) String(ata6613c) Value(94)
---
> Enum(avr_mcu) String(atmega168) Value(94)
312c312
< Enum(avr_mcu) String(ata6614q) Value(95)
---
> Enum(avr_mcu) String(atmega168a) Value(95)
315c315
< Enum(avr_mcu) String(atmega16) Value(96)
---
> Enum(avr_mcu) String(atmega168p) Value(96)
318c318
< Enum(avr_mcu) String(atmega16a) Value(97)
---
> Enum(avr_mcu) String(atmega168pa) Value(97)
321c321
< Enum(avr_mcu) String(atmega161) Value(98)
---
> Enum(avr_mcu) String(atmega169) Value(98)
324c324
< Enum(avr_mcu) String(atmega162) Value(99)
---
> Enum(avr_mcu) String(atmega169a) Value(99)
327c327
< Enum(avr_mcu) String(atmega163) Value(100)
---
> Enum(avr_mcu) String(atmega169p) Value(100)
330c330
< Enum(avr_mcu) String(atmega164a) Value(101)
---
> Enum(avr_mcu) String(atmega169pa) Value(101)
333c333
< Enum(avr_mcu) String(atmega164p) Value(102)
---
> Enum(avr_mcu) String(atmega16hva) Value(102)
336c336
< Enum(avr_mcu) String(atmega164pa) Value(103)
---
> Enum(avr_mcu) String(atmega16hvb) Value(103)
339c339
< Enum(avr_mcu) String(atmega165) Value(104)
---
> Enum(avr_mcu) String(atmega16hvbrevb) Value(104)
342c342
< Enum(avr_mcu) String(atmega165a) Value(105)
---
> Enum(avr_mcu) String(atmega16m1) Value(105)
345c345
< Enum(avr_mcu) String(atmega165p) Value(106)
---
> Enum(avr_mcu) String(atmega16u4) Value(106)
348c348
< Enum(avr_mcu) String(atmega165pa) Value(107)
---
> Enum(avr_mcu) String(atmega26hvg) Value(107)
351c351
< Enum(avr_mcu) String(atmega168) Value(108)
---
> Enum(avr_mcu) String(atmega32a) Value(108)
354c354
< Enum(avr_mcu) String(atmega168a) Value(109)
---
> Enum(avr_mcu) String(atmega32) Value(109)
357c357
< Enum(avr_mcu) String(atmega168p) Value(110)
---
> Enum(avr_mcu) String(atmega32a) Value(110)
360c360
< Enum(avr_mcu) String(atmega168pa) Value(111)
---
> Enum(avr_mcu) String(atmega323) Value(111)
363c363
< Enum(avr_mcu) String(atmega168pb) Value(112)
---
> Enum(avr_mcu) String(atmega324a) Value(112)
366c366
< Enum(avr_mcu) String(atmega169) Value(113)
---
> Enum(avr_mcu) String(atmega324p) Value(113)
369c369
< Enum(avr_mcu) String(atmega169a) Value(114)
---
> Enum(avr_mcu) String(atmega324pa) Value(114)
372c372
< Enum(avr_mcu) String(atmega169p) Value(115)
---
> Enum(avr_mcu) String(atmega325) Value(115)
375c375
< Enum(avr_mcu) String(atmega169pa) Value(116)
---
> Enum(avr_mcu) String(atmega325a) Value(116)
378c378
< Enum(avr_mcu) String(atmega16hvb) Value(117)
---
> Enum(avr_mcu) String(atmega325p) Value(117)
381c381
< Enum(avr_mcu) String(atmega16hvbrevb) Value(118)
---
> Enum(avr_mcu) String(atmega3250) Value(118)
384c384
< Enum(avr_mcu) String(atmega16m1) Value(119)
---
> Enum(avr_mcu) String(atmega3250a) Value(119)
387c387
< Enum(avr_mcu) String(atmega16u4) Value(120)
---
> Enum(avr_mcu) String(atmega3250p) Value(120)
390c390
< Enum(avr_mcu) String(atmega32a) Value(121)
---
> Enum(avr_mcu) String(atmega3250pa) Value(121)
393c393
< Enum(avr_mcu) String(atmega32) Value(122)
---
> Enum(avr_mcu) String(atmega328) Value(122)
396c396
< Enum(avr_mcu) String(atmega323) Value(123)
---
> Enum(avr_mcu) String(atmega328p) Value(123)
399c399
< Enum(avr_mcu) String(atmega324a) Value(124)
---
> Enum(avr_mcu) String(atmega329) Value(124)
402c402
< Enum(avr_mcu) String(atmega324p) Value(125)
---
> Enum(avr_mcu) String(atmega329a) Value(125)
405c405
< Enum(avr_mcu) String(atmega324pa) Value(126)
---
> Enum(avr_mcu) String(atmega329p) Value(126)
408c408
< Enum(avr_mcu) String(atmega325) Value(127)
---
> Enum(avr_mcu) String(atmega329pa) Value(127)
411c411
< Enum(avr_mcu) String(atmega325a) Value(128)
---
> Enum(avr_mcu) String(atmega3290) Value(128)
414c414
< Enum(avr_mcu) String(atmega325p) Value(129)
---
> Enum(avr_mcu) String(atmega3290a) Value(129)
417c417
< Enum(avr_mcu) String(atmega325pa) Value(130)
---
> Enum(avr_mcu) String(atmega3290p) Value(130)
420c420
< Enum(avr_mcu) String(atmega3250) Value(131)
---
> Enum(avr_mcu) String(atmega3290pa) Value(131)
423c423
< Enum(avr_mcu) String(atmega3250a) Value(132)
---
> Enum(avr_mcu) String(atmega32c1) Value(132)
426c426
< Enum(avr_mcu) String(atmega3250p) Value(133)
---
> Enum(avr_mcu) String(atmega32m1) Value(133)
429c429
< Enum(avr_mcu) String(atmega3250pa) Value(134)
---
> Enum(avr_mcu) String(atmega32u4) Value(134)
432c432
< Enum(avr_mcu) String(atmega328) Value(135)
---
> Enum(avr_mcu) String(atmega32u6) Value(135)
435c435
< Enum(avr_mcu) String(atmega328p) Value(136)
---
> Enum(avr_mcu) String(atmega406) Value(136)
438c438
< Enum(avr_mcu) String(atmega329) Value(137)
---
> Enum(avr_mcu) String(atmega64) Value(137)
441c441
< Enum(avr_mcu) String(atmega329a) Value(138)
---
> Enum(avr_mcu) String(atmega64a) Value(138)
444c444
< Enum(avr_mcu) String(atmega329p) Value(139)
---
> Enum(avr_mcu) String(atmega640) Value(139)
447c447
< Enum(avr_mcu) String(atmega329pa) Value(140)
---
> Enum(avr_mcu) String(atmega644) Value(140)
450c450
< Enum(avr_mcu) String(atmega3290) Value(141)
---
> Enum(avr_mcu) String(atmega644a) Value(141)
453c453
< Enum(avr_mcu) String(atmega3290a) Value(142)
---
> Enum(avr_mcu) String(atmega644p) Value(142)
456c456
< Enum(avr_mcu) String(atmega3290p) Value(143)
---
> Enum(avr_mcu) String(atmega644pa) Value(143)
459c459
< Enum(avr_mcu) String(atmega3290pa) Value(144)
---
> Enum(avr_mcu) String(atmega645) Value(144)
462c462
< Enum(avr_mcu) String(atmega32c1) Value(145)
---
> Enum(avr_mcu) String(atmega645a) Value(145)
465c465
< Enum(avr_mcu) String(atmega32m1) Value(146)
---
> Enum(avr_mcu) String(atmega645p) Value(146)
468c468
< Enum(avr_mcu) String(atmega32u4) Value(147)
---
> Enum(avr_mcu) String(atmega6450) Value(147)
471c471
< Enum(avr_mcu) String(atmega32u6) Value(148)
---
> Enum(avr_mcu) String(atmega6450a) Value(148)
474c474
< Enum(avr_mcu) String(atmega406) Value(149)
---
> Enum(avr_mcu) String(atmega6450p) Value(149)
477c477
< Enum(avr_mcu) String(atmega64) Value(150)
---
> Enum(avr_mcu) String(atmega649) Value(150)
480c480
< Enum(avr_mcu) String(atmega64a) Value(151)
---
> Enum(avr_mcu) String(atmega649a) Value(151)
483c483
< Enum(avr_mcu) String(atmega640) Value(152)
---
> Enum(avr_mcu) String(atmega649p) Value(152)
486c486
< Enum(avr_mcu) String(atmega644) Value(153)
---
> Enum(avr_mcu) String(atmega6490) Value(153)
489c489
< Enum(avr_mcu) String(atmega644a) Value(154)
---
> Enum(avr_mcu) String(atmega16hva) Value(154)
492c492
< Enum(avr_mcu) String(atmega644p) Value(155)
---
> Enum(avr_mcu) String(atmega16hva2) Value(155)
495c495
< Enum(avr_mcu) String(atmega644pa) Value(156)
---
> Enum(avr_mcu) String(atmega16hvb) Value(156)
498c498
< Enum(avr_mcu) String(atmega645) Value(157)
---
> Enum(avr_mcu) String(atmega32hvb) Value(157)
501c501
< Enum(avr_mcu) String(atmega645a) Value(158)
---
> Enum(avr_mcu) String(atmega6490a) Value(158)
504c504
< Enum(avr_mcu) String(atmega645p) Value(159)
---
> Enum(avr_mcu) String(atmega6490p) Value(159)
507c507
< Enum(avr_mcu) String(atmega6450) Value(160)
---
> Enum(avr_mcu) String(atmega64c1) Value(160)
510c510
< Enum(avr_mcu) String(atmega6450a) Value(161)
---
> Enum(avr_mcu) String(atmega64m1) Value(161)
513c513
< Enum(avr_mcu) String(atmega6450p) Value(162)
---
> Enum(avr_mcu) String(atmega64hve) Value(162)
516c516
< Enum(avr_mcu) String(atmega649) Value(163)
---
> Enum(avr_mcu) String(atmega64rfa2) Value(163)
519c519
< Enum(avr_mcu) String(atmega649a) Value(164)
---
> Enum(avr_mcu) String(atmega64rfr2) Value(164)
522c522
< Enum(avr_mcu) String(atmega649p) Value(165)
---
> Enum(avr_mcu) String(atmega32hvb) Value(165)
525c525
< Enum(avr_mcu) String(atmega6490) Value(166)
---
> Enum(avr_mcu) String(atmega32hvbrevb) Value(166)
528c528
< Enum(avr_mcu) String(atmega16hva) Value(167)
---
> Enum(avr_mcu) String(atmega16hva2) Value(167)
531c531
< Enum(avr_mcu) String(atmega16hva2) Value(168)
---
> Enum(avr_mcu) String(atmega48hvf) Value(168)
534c534
< Enum(avr_mcu) String(atmega32hvb) Value(169)
---
> Enum(avr_mcu) String(at90can32) Value(169)
537c537
< Enum(avr_mcu) String(atmega6490a) Value(170)
---
> Enum(avr_mcu) String(at90can64) Value(170)
540c540
< Enum(avr_mcu) String(atmega6490p) Value(171)
---
> Enum(avr_mcu) String(at90pwm161) Value(171)
543c543
< Enum(avr_mcu) String(atmega64c1) Value(172)
---
> Enum(avr_mcu) String(at90pwm216) Value(172)
546c546
< Enum(avr_mcu) String(atmega64m1) Value(173)
---
> Enum(avr_mcu) String(at90pwm316) Value(173)
549c549
< Enum(avr_mcu) String(atmega64hve) Value(174)
---
> Enum(avr_mcu) String(atmega32c1) Value(174)
552c552
< Enum(avr_mcu) String(atmega64hve2) Value(175)
---
> Enum(avr_mcu) String(atmega64c1) Value(175)
555c555
< Enum(avr_mcu) String(atmega64rfr2) Value(176)
---
> Enum(avr_mcu) String(atmega16m1) Value(176)
558c558
< Enum(avr_mcu) String(atmega644rfr2) Value(177)
---
> Enum(avr_mcu) String(atmega32m1) Value(177)
561c561
< Enum(avr_mcu) String(atmega32hvbrevb) Value(178)
---
> Enum(avr_mcu) String(atmega64m1) Value(178)
564c564
< Enum(avr_mcu) String(at90can32) Value(179)
---
> Enum(avr_mcu) String(atmega16u4) Value(179)
567c567
< Enum(avr_mcu) String(at90can64) Value(180)
---
> Enum(avr_mcu) String(atmega32u4) Value(180)
570c570
< Enum(avr_mcu) String(at90pwm161) Value(181)
---
> Enum(avr_mcu) String(atmega32u6) Value(181)
573c573
< Enum(avr_mcu) String(at90pwm216) Value(182)
---
> Enum(avr_mcu) String(at90scr100) Value(182)
576c576
< Enum(avr_mcu) String(at90pwm316) Value(183)
---
> Enum(avr_mcu) String(at90usb646) Value(183)
579c579
< Enum(avr_mcu) String(at90scr100) Value(184)
---
> Enum(avr_mcu) String(at90usb647) Value(184)
582c582
< Enum(avr_mcu) String(at90usb646) Value(185)
---
> Enum(avr_mcu) String(at94k) Value(185)
585c585
< Enum(avr_mcu) String(at90usb647) Value(186)
---
> Enum(avr_mcu) String(m3000) Value(186)
588c588
< Enum(avr_mcu) String(at94k) Value(187)
---
> Enum(avr_mcu) String(avr51) Value(187)
591c591
< Enum(avr_mcu) String(m3000) Value(188)
---
> Enum(avr_mcu) String(atmega128) Value(188)
594c594
< Enum(avr_mcu) String(avr51) Value(189)
---
> Enum(avr_mcu) String(atmega128a) Value(189)
597c597
< Enum(avr_mcu) String(atmega128) Value(190)
---
> Enum(avr_mcu) String(atmega1280) Value(190)
600c600
< Enum(avr_mcu) String(atmega128a) Value(191)
---
> Enum(avr_mcu) String(atmega1281) Value(191)
603c603
< Enum(avr_mcu) String(atmega1280) Value(192)
---
> Enum(avr_mcu) String(atmega1284) Value(192)
606c606
< Enum(avr_mcu) String(atmega1281) Value(193)
---
> Enum(avr_mcu) String(atmega1284p) Value(193)
609c609
< Enum(avr_mcu) String(atmega1284) Value(194)
---
> Enum(avr_mcu) String(atmega128rfa1) Value(194)
612c612
< Enum(avr_mcu) String(atmega1284p) Value(195)
---
> Enum(avr_mcu) String(at90can128) Value(195)
615c615
< Enum(avr_mcu) String(atmega128rfa1) Value(196)
---
> Enum(avr_mcu) String(at90usb1286) Value(196)
618c618
< Enum(avr_mcu) String(atmega128rfr2) Value(197)
---
> Enum(avr_mcu) String(at90usb1287) Value(197)
621c621
< Enum(avr_mcu) String(atmega1284rfr2) Value(198)
---
> Enum(avr_mcu) String(avr6) Value(198)
624c624
< Enum(avr_mcu) String(at90can128) Value(199)
---
> Enum(avr_mcu) String(atmega2560) Value(199)
627c627
< Enum(avr_mcu) String(at90usb1286) Value(200)
---
> Enum(avr_mcu) String(atmega2561) Value(200)
630c630
< Enum(avr_mcu) String(at90usb1287) Value(201)
---
> Enum(avr_mcu) String(avrxmega2) Value(201)
633c633
< Enum(avr_mcu) String(avr6) Value(202)
---
> Enum(avr_mcu) String(atxmega16a4) Value(202)
636c636
< Enum(avr_mcu) String(atmega2560) Value(203)
---
> Enum(avr_mcu) String(atxmega16d4) Value(203)
639c639
< Enum(avr_mcu) String(atmega2561) Value(204)
---
> Enum(avr_mcu) String(atxmega16x1) Value(204)
642c642
< Enum(avr_mcu) String(atmega256rfr2) Value(205)
---
> Enum(avr_mcu) String(atxmega32a4) Value(205)
645c645
< Enum(avr_mcu) String(atmega2564rfr2) Value(206)
---
> Enum(avr_mcu) String(atxmega32d4) Value(206)
648c648
< Enum(avr_mcu) String(avrxmega2) Value(207)
---
> Enum(avr_mcu) String(atxmega32x1) Value(207)
651c651
< Enum(avr_mcu) String(atxmega8e5) Value(208)
---
> Enum(avr_mcu) String(atmxt112sl) Value(208)
654c654
< Enum(avr_mcu) String(atxmega16a4) Value(209)
---
> Enum(avr_mcu) String(atmxt224) Value(209)
657c657
< Enum(avr_mcu) String(atxmega16a4u) Value(210)
---
> Enum(avr_mcu) String(atmxt224e) Value(210)
660c660
< Enum(avr_mcu) String(atxmega16c4) Value(211)
---
> Enum(avr_mcu) String(atmxt336s) Value(211)
663c663
< Enum(avr_mcu) String(atxmega16d4) Value(212)
---
> Enum(avr_mcu) String(atxmega16a4u) Value(212)
666c666
< Enum(avr_mcu) String(atxmega16e5) Value(213)
---
> Enum(avr_mcu) String(atxmega16c4) Value(213)
669c669
< Enum(avr_mcu) String(atxmega32a4) Value(214)
---
> Enum(avr_mcu) String(atxmega32a4u) Value(214)
672c672
< Enum(avr_mcu) String(atxmega32a4u) Value(215)
---
> Enum(avr_mcu) String(atxmega32c4) Value(215)
675c675
< Enum(avr_mcu) String(atxmega32c3) Value(216)
---
> Enum(avr_mcu) String(atxmega32e5) Value(216)
678c678
< Enum(avr_mcu) String(atxmega32c4) Value(217)
---
> Enum(avr_mcu) String(avrxmega4) Value(217)
681c681
< Enum(avr_mcu) String(atxmega32d3) Value(218)
---
> Enum(avr_mcu) String(atxmega64a3) Value(218)
684c684
< Enum(avr_mcu) String(atxmega32d4) Value(219)
---
> Enum(avr_mcu) String(atxmega64d3) Value(219)
687c687
< Enum(avr_mcu) String(atxmega32e5) Value(220)
---
> Enum(avr_mcu) String(atxmega64a3u) Value(220)
690c690
< Enum(avr_mcu) String(avrxmega4) Value(221)
---
> Enum(avr_mcu) String(atxmega64a4u) Value(221)
693c693
< Enum(avr_mcu) String(atxmega64a3) Value(222)
---
> Enum(avr_mcu) String(atxmega64b1) Value(222)
696c696
< Enum(avr_mcu) String(atxmega64a3u) Value(223)
---
> Enum(avr_mcu) String(atxmega64b3) Value(223)
699c699
< Enum(avr_mcu) String(atxmega64a4u) Value(224)
---
> Enum(avr_mcu) String(atxmega64c3) Value(224)
702c702
< Enum(avr_mcu) String(atxmega64b1) Value(225)
---
> Enum(avr_mcu) String(atxmega64d4) Value(225)
705c705
< Enum(avr_mcu) String(atxmega64b3) Value(226)
---
> Enum(avr_mcu) String(avrxmega5) Value(226)
708c708
< Enum(avr_mcu) String(atxmega64c3) Value(227)
---
> Enum(avr_mcu) String(atxmega64a1) Value(227)
711c711
< Enum(avr_mcu) String(atxmega64d3) Value(228)
---
> Enum(avr_mcu) String(atxmega64a1u) Value(228)
714c714
< Enum(avr_mcu) String(atxmega64d4) Value(229)
---
> Enum(avr_mcu) String(avrxmega6) Value(229)
717c717
< Enum(avr_mcu) String(avrxmega5) Value(230)
---
> Enum(avr_mcu) String(atxmega128a3) Value(230)
720c720
< Enum(avr_mcu) String(atxmega64a1) Value(231)
---
> Enum(avr_mcu) String(atxmega128d3) Value(231)
723c723
< Enum(avr_mcu) String(atxmega64a1u) Value(232)
---
> Enum(avr_mcu) String(atxmega192a3) Value(232)
726c726
< Enum(avr_mcu) String(avrxmega6) Value(233)
---
> Enum(avr_mcu) String(atxmega192d3) Value(233)
729c729
< Enum(avr_mcu) String(atxmega128a3) Value(234)
---
> Enum(avr_mcu) String(atxmega256a3) Value(234)
732c732
< Enum(avr_mcu) String(atxmega128a3u) Value(235)
---
> Enum(avr_mcu) String(atxmega256a3b) Value(235)
735c735
< Enum(avr_mcu) String(atxmega128b1) Value(236)
---
> Enum(avr_mcu) String(atxmega256a3bu) Value(236)
738c738
< Enum(avr_mcu) String(atxmega128b3) Value(237)
---
> Enum(avr_mcu) String(atxmega256d3) Value(237)
741c741
< Enum(avr_mcu) String(atxmega128c3) Value(238)
---
> Enum(avr_mcu) String(atxmega128a3u) Value(238)
744c744
< Enum(avr_mcu) String(atxmega128d3) Value(239)
---
> Enum(avr_mcu) String(atxmega128b1) Value(239)
747c747
< Enum(avr_mcu) String(atxmega128d4) Value(240)
---
> Enum(avr_mcu) String(atxmega128b3) Value(240)
750c750
< Enum(avr_mcu) String(atxmega192a3) Value(241)
---
> Enum(avr_mcu) String(atxmega128c3) Value(241)
753c753
< Enum(avr_mcu) String(atxmega192a3u) Value(242)
---
> Enum(avr_mcu) String(atxmega128d4) Value(242)
756c756
< Enum(avr_mcu) String(atxmega192c3) Value(243)
---
> Enum(avr_mcu) String(atmxt540s) Value(243)
759c759
< Enum(avr_mcu) String(atxmega192d3) Value(244)
---
> Enum(avr_mcu) String(atmxt540sreva) Value(244)
762c762
< Enum(avr_mcu) String(atxmega256a3) Value(245)
---
> Enum(avr_mcu) String(atxmega192a3u) Value(245)
765c765
< Enum(avr_mcu) String(atxmega256a3b) Value(246)
---
> Enum(avr_mcu) String(atxmega192c3) Value(246)
768c768
< Enum(avr_mcu) String(atxmega256a3bu) Value(247)
---
> Enum(avr_mcu) String(atxmega256a3u) Value(247)
771c771
< Enum(avr_mcu) String(atxmega256a3u) Value(248)
---
> Enum(avr_mcu) String(atxmega256c3) Value(248)
774c774
< Enum(avr_mcu) String(atxmega256c3) Value(249)
---
> Enum(avr_mcu) String(atxmega384c3) Value(249)
777c777
< Enum(avr_mcu) String(atxmega256d3) Value(250)
---
> Enum(avr_mcu) String(atxmega384d3) Value(250)
780c780
< Enum(avr_mcu) String(atxmega384c3) Value(251)
---
> Enum(avr_mcu) String(avrxmega7) Value(251)
783c783
< Enum(avr_mcu) String(atxmega384d3) Value(252)
---
> Enum(avr_mcu) String(atxmega128a1) Value(252)
786c786
< Enum(avr_mcu) String(avrxmega7) Value(253)
---
> Enum(avr_mcu) String(atxmega128a1u) Value(253)
789c789
< Enum(avr_mcu) String(atxmega128a1) Value(254)
---
> Enum(avr_mcu) String(atxmega128a4u) Value(254)
792c792
< Enum(avr_mcu) String(atxmega128a1u) Value(255)
---
> Enum(avr_mcu) String(avr1) Value(255)
795c795
< Enum(avr_mcu) String(atxmega128a4u) Value(256)
---
> Enum(avr_mcu) String(at90s1200) Value(256)
798c798
< Enum(avr_mcu) String(avrtiny) Value(257)
---
> Enum(avr_mcu) String(attiny11) Value(257)
801c801
< Enum(avr_mcu) String(attiny4) Value(258)
---
> Enum(avr_mcu) String(attiny12) Value(258)
804c804
< Enum(avr_mcu) String(attiny5) Value(259)
---
> Enum(avr_mcu) String(attiny15) Value(259)
807,834c807
< Enum(avr_mcu) String(attiny9) Value(260)
< 
< EnumValue
< Enum(avr_mcu) String(attiny10) Value(261)
< 
< EnumValue
< Enum(avr_mcu) String(attiny20) Value(262)
< 
< EnumValue
< Enum(avr_mcu) String(attiny40) Value(263)
< 
< EnumValue
< Enum(avr_mcu) String(avr1) Value(264)
< 
< EnumValue
< Enum(avr_mcu) String(at90s1200) Value(265)
< 
< EnumValue
< Enum(avr_mcu) String(attiny11) Value(266)
< 
< EnumValue
< Enum(avr_mcu) String(attiny12) Value(267)
< 
< EnumValue
< Enum(avr_mcu) String(attiny15) Value(268)
< 
< EnumValue
< Enum(avr_mcu) String(attiny28) Value(269)
---
> Enum(avr_mcu) String(attiny28) Value(260)
diff -r avr/gcc/config/avr/driver-avr.c gcc/gcc/config/avr/driver-avr.c
62,63c62,63
<     avr_current_device->dev_attribute & AVR_ERRATA_SKIP ? "" : " -mno-skip-bug",
<     avr_current_device->dev_attribute & AVR_ISA_RMW ? " -mrmw" : "", NULL);
---
>                  avr_current_device->errata_skip ? "" : " -mno-skip-bug",
>                  NULL);
104,127d103
< /* Returns command line parameters that describe start of text section.  */
< 
< const char *
< avr_device_to_text_start (int argc, const char **argv)
< {
<   unsigned long text_section_start;
<   char text_section_start_str[16];
< 
<   if (0 == argc)
<     return NULL;
< 
<   avr_set_current_device (argv[0]);
< 
<   if (avr_current_device->text_section_start == 0)
<     return NULL;
< 
<   text_section_start = avr_current_device->text_section_start;
< 
<   snprintf (text_section_start_str, sizeof(text_section_start_str) - 1,
<             "0x%lX", text_section_start);
< 
<   return concat ("-Ttext ", text_section_start_str, NULL);
< }
< 
171c147
<   return (avr_current_device->dev_attribute & AVR_SHORT_SP)
---
>   return avr_current_device->short_sp
diff -r avr/gcc/config/avr/gen-avr-mmcu-texi.c gcc/gcc/config/avr/gen-avr-mmcu-texi.c
71d70
<   int duplicate = 0;
82,95c81
<     {
<       printf (" @code{%s}%s", mcu_name[i], i == n_mcus-1 ? ".\n\n" : ",");
< 
<       if (i && !strcmp (mcu_name[i], mcu_name[i-1]))
<         {
<           /* Sanity-check: Fail on devices that are present more than once.  */
< 
<           duplicate = 1;
<           fprintf (stderr, "error: duplicate device: %s\n", mcu_name[i]);
<         }
<     }
< 
<   if (duplicate)
<     exit (1);
---
>     printf (" @code{%s}%s", mcu_name[i], i == n_mcus-1 ? ".\n\n" : ",");
diff -r avr/gcc/config/avr/genmultilib.awk gcc/gcc/config/avr/genmultilib.awk
89c89
<     if ($5 == "NULL")
---
>     if ($4 == "NULL")
109,119c109
<     # split device specific feature list
<     n = split($4,dev_attribute,"|")
< 
<     # set tiny_stack false by default
<     tiny_stack[name] = 0
<     for (i=1; i <= n; i++)
<       if (dev_attribute[i] == "AVR_SHORT_SP") {
<         tiny_stack[name] = 1
<         break
<       }
< 
---
>     tiny_stack[name]  = $5
diff -r avr/gcc/config/avr/t-multilib gcc/gcc/config/avr/t-multilib
24c24
< MULTILIB_OPTIONS = mmcu=avr2/mmcu=avr25/mmcu=avr3/mmcu=avr31/mmcu=avr35/mmcu=avr4/mmcu=avr5/mmcu=avr51/mmcu=avr6/mmcu=avrxmega2/mmcu=avrxmega4/mmcu=avrxmega5/mmcu=avrxmega6/mmcu=avrxmega7/mmcu=avrtiny msp8
---
> MULTILIB_OPTIONS = mmcu=avr2/mmcu=avr25/mmcu=avr3/mmcu=avr31/mmcu=avr35/mmcu=avr4/mmcu=avr5/mmcu=avr51/mmcu=avr6/mmcu=avrxmega2/mmcu=avrxmega4/mmcu=avrxmega5/mmcu=avrxmega6/mmcu=avrxmega7 msp8
26c26
< MULTILIB_DIRNAMES =  avr2 avr25 avr3 avr31 avr35 avr4 avr5 avr51 avr6 avrxmega2 avrxmega4 avrxmega5 avrxmega6 avrxmega7 avrtiny tiny-stack avr25/tiny-stack
---
> MULTILIB_DIRNAMES =  avr2 avr25 avr3 avr31 avr35 avr4 avr5 avr51 avr6 avrxmega2 avrxmega4 avrxmega5 avrxmega6 avrxmega7 tiny-stack avr25/tiny-stack
40,41c40
< 	mmcu=avrxmega7/msp8 \
< 	mmcu=avrtiny/msp8
---
> 	mmcu=avrxmega7/msp8
55a55
> 	mmcu?avr25=mmcu?ata6289 \
57d56
< 	mmcu?avr25=mmcu?ata6616c \
67d65
< 	mmcu?avr25=mmcu?attiny441 \
83,84d80
< 	mmcu?avr25=mmcu?attiny828 \
< 	mmcu?avr25=mmcu?attiny841 \
91,92d86
< 	mmcu?avr35=mmcu?ata6617c \
< 	mmcu?avr35=mmcu?ata664251 \
102,103d95
< 	mmcu?avr4=mmcu?ata6289 \
< 	mmcu?avr4=mmcu?ata6612c \
110d101
< 	mmcu?avr4=mmcu?atmega48pb \
115d105
< 	mmcu?avr4=mmcu?atmega88pb \
125,126d114
< 	mmcu?avr5=mmcu?ata5702m322 \
< 	mmcu?avr5=mmcu?ata5782 \
130,132d117
< 	mmcu?avr5=mmcu?ata5831 \
< 	mmcu?avr5=mmcu?ata6613c \
< 	mmcu?avr5=mmcu?ata6614q \
149d133
< 	mmcu?avr5=mmcu?atmega168pb \
153a138
> 	mmcu?avr5=mmcu?atmega16hva \
157a143
> 	mmcu?avr5=mmcu?atmega26hvg \
159a146
> 	mmcu?avr5=mmcu?atmega32a \
167d153
< 	mmcu?avr5=mmcu?atmega325pa \
205a192
> 	mmcu?avr5=mmcu?atmega16hvb \
212c199
< 	mmcu?avr5=mmcu?atmega64hve2 \
---
> 	mmcu?avr5=mmcu?atmega64rfa2 \
214c201
< 	mmcu?avr5=mmcu?atmega644rfr2 \
---
> 	mmcu?avr5=mmcu?atmega32hvb \
215a203,204
> 	mmcu?avr5=mmcu?atmega16hva2 \
> 	mmcu?avr5=mmcu?atmega48hvf \
220a210,217
> 	mmcu?avr5=mmcu?atmega32c1 \
> 	mmcu?avr5=mmcu?atmega64c1 \
> 	mmcu?avr5=mmcu?atmega16m1 \
> 	mmcu?avr5=mmcu?atmega32m1 \
> 	mmcu?avr5=mmcu?atmega64m1 \
> 	mmcu?avr5=mmcu?atmega16u4 \
> 	mmcu?avr5=mmcu?atmega32u4 \
> 	mmcu?avr5=mmcu?atmega32u6 \
233,234d229
< 	mmcu?avr51=mmcu?atmega128rfr2 \
< 	mmcu?avr51=mmcu?atmega1284rfr2 \
240,242d234
< 	mmcu?avr6=mmcu?atmega256rfr2 \
< 	mmcu?avr6=mmcu?atmega2564rfr2 \
< 	mmcu?avrxmega2=mmcu?atxmega8e5 \
244,245d235
< 	mmcu?avrxmega2=mmcu?atxmega16a4u \
< 	mmcu?avrxmega2=mmcu?atxmega16c4 \
247c237
< 	mmcu?avrxmega2=mmcu?atxmega16e5 \
---
> 	mmcu?avrxmega2=mmcu?atxmega16x1 \
248a239,246
> 	mmcu?avrxmega2=mmcu?atxmega32d4 \
> 	mmcu?avrxmega2=mmcu?atxmega32x1 \
> 	mmcu?avrxmega2=mmcu?atmxt112sl \
> 	mmcu?avrxmega2=mmcu?atmxt224 \
> 	mmcu?avrxmega2=mmcu?atmxt224e \
> 	mmcu?avrxmega2=mmcu?atmxt336s \
> 	mmcu?avrxmega2=mmcu?atxmega16a4u \
> 	mmcu?avrxmega2=mmcu?atxmega16c4 \
250d247
< 	mmcu?avrxmega2=mmcu?atxmega32c3 \
252,253d248
< 	mmcu?avrxmega2=mmcu?atxmega32d3 \
< 	mmcu?avrxmega2=mmcu?atxmega32d4 \
255a251
> 	mmcu?avrxmega4=mmcu?atxmega64d3 \
261d256
< 	mmcu?avrxmega4=mmcu?atxmega64d3 \
265a261,267
> 	mmcu?avrxmega6=mmcu?atxmega128d3 \
> 	mmcu?avrxmega6=mmcu?atxmega192a3 \
> 	mmcu?avrxmega6=mmcu?atxmega192d3 \
> 	mmcu?avrxmega6=mmcu?atxmega256a3 \
> 	mmcu?avrxmega6=mmcu?atxmega256a3b \
> 	mmcu?avrxmega6=mmcu?atxmega256a3bu \
> 	mmcu?avrxmega6=mmcu?atxmega256d3 \
270d271
< 	mmcu?avrxmega6=mmcu?atxmega128d3 \
272c273,274
< 	mmcu?avrxmega6=mmcu?atxmega192a3 \
---
> 	mmcu?avrxmega6=mmcu?atmxt540s \
> 	mmcu?avrxmega6=mmcu?atmxt540sreva \
275,278d276
< 	mmcu?avrxmega6=mmcu?atxmega192d3 \
< 	mmcu?avrxmega6=mmcu?atxmega256a3 \
< 	mmcu?avrxmega6=mmcu?atxmega256a3b \
< 	mmcu?avrxmega6=mmcu?atxmega256a3bu \
281d278
< 	mmcu?avrxmega6=mmcu?atxmega256d3 \
286,292c283
< 	mmcu?avrxmega7=mmcu?atxmega128a4u \
< 	mmcu?avrtiny=mmcu?attiny4 \
< 	mmcu?avrtiny=mmcu?attiny5 \
< 	mmcu?avrtiny=mmcu?attiny9 \
< 	mmcu?avrtiny=mmcu?attiny10 \
< 	mmcu?avrtiny=mmcu?attiny20 \
< 	mmcu?avrtiny=mmcu?attiny40
---
> 	mmcu?avrxmega7=mmcu?atxmega128a4u
