/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.2.0
 * Git version: dcef523
 * Options:   --no-safe-math --no-math64 --no-bitfields --no-consts --no-float --no-divs --max-array-dim 2 --max-array-len-per-dim 8 --max-block-depth 2 --max-block-size 2 --max-expr-complexity 2 --max-funcs 4 --max-struct-fields 2 --max-union-fields 2 --output /specific/a/home/cc/students/cs/alonelmaliah//Desktop/avrTest/WorkFolder/avrtest.c
 * Seed:      867722195
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint16_t  f0;
};
#pragma pack(pop)

struct S1 {
   volatile struct S0  f0;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_3 = 0x76E6BACDL;
static volatile uint32_t g_20 = 3UL;/* VOLATILE GLOBAL g_20 */
static int32_t g_43 = 1L;
static struct S0 g_46 = {0xDD36L};
static volatile int32_t g_50 = 1L;/* VOLATILE GLOBAL g_50 */
static volatile int32_t * volatile g_49 = &g_50;/* VOLATILE GLOBAL g_49 */
static volatile int32_t * volatile *g_48 = &g_49;
static volatile int32_t * volatile ** volatile g_51 = &g_48;/* VOLATILE GLOBAL g_51 */
static struct S1 g_53 = {{1UL}};/* VOLATILE GLOBAL g_53 */
static struct S1 *g_55 = (void*)0;
static struct S1 ** volatile g_54 = &g_55;/* VOLATILE GLOBAL g_54 */
static uint8_t g_69[7][6] = {{5UL,246UL,255UL,255UL,246UL,5UL},{247UL,8UL,255UL,5UL,0UL,247UL},{0x87L,8UL,5UL,0x87L,246UL,0x87L},{0x87L,246UL,0x87L,5UL,8UL,0x87L},{247UL,0UL,5UL,255UL,8UL,247UL},{5UL,246UL,255UL,255UL,246UL,5UL},{247UL,8UL,255UL,5UL,0UL,247UL}};
static volatile uint16_t g_83 = 0x12EDL;/* VOLATILE GLOBAL g_83 */
static volatile uint8_t g_100[4] = {255UL,255UL,255UL,255UL};
static uint16_t g_106 = 0x2398L;
static struct S0 g_107 = {0x8BC2L};
static int32_t g_110 = 0x6681864DL;
static int32_t *g_109 = &g_110;
static volatile int8_t g_125 = 0x0CL;/* VOLATILE GLOBAL g_125 */
static int16_t g_127 = 1L;
static int16_t g_128 = 0xD75DL;
static int32_t g_131 = 3L;
static volatile uint32_t g_133 = 0x97AB8FBBL;/* VOLATILE GLOBAL g_133 */


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_1(void);
static int32_t  func_23(uint32_t  p_24, int32_t * p_25, int32_t * p_26, int32_t  p_27, uint32_t  p_28);
static uint16_t  func_31(struct S0  p_32, uint16_t  p_33, struct S0  p_34);
static uint8_t  func_35(int32_t  p_36, int32_t * p_37, int32_t * p_38, int32_t * p_39, struct S0  p_40);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_20 g_3 g_46 g_48 g_51 g_54 g_49 g_50 g_83 g_55 g_100 g_53 g_106 g_107 g_109 g_110 g_133 g_43
 * writes: g_20 g_43 g_46.f0 g_48 g_55 g_69 g_83 g_49 g_100 g_3 g_110 g_133
 */
static uint16_t  func_1(void)
{ /* block id: 0 */
    int32_t *l_2 = &g_3;
    int32_t *l_4 = &g_3;
    int32_t l_5 = 0L;
    int32_t *l_6 = &l_5;
    int32_t *l_7 = (void*)0;
    int32_t *l_8 = &g_3;
    int32_t *l_9 = &g_3;
    int32_t *l_10 = &l_5;
    int32_t *l_11 = &g_3;
    int32_t *l_12 = (void*)0;
    int32_t *l_13 = &g_3;
    int32_t *l_14 = &g_3;
    int32_t *l_15 = &g_3;
    int32_t *l_16 = &l_5;
    int32_t *l_17 = &l_5;
    int32_t *l_18 = (void*)0;
    int32_t *l_19[3];
    uint32_t l_41 = 0x6E311378L;
    int32_t *l_42 = &g_43;
    uint32_t l_44[5][1];
    int32_t *l_45 = &l_5;
    uint8_t l_108[4] = {0xA5L,0xA5L,0xA5L,0xA5L};
    uint8_t l_111 = 2UL;
    int i, j;
    for (i = 0; i < 3; i++)
        l_19[i] = &l_5;
    for (i = 0; i < 5; i++)
    {
        for (j = 0; j < 1; j++)
            l_44[i][j] = 0UL;
    }
    ++g_20;
    (*l_11) = ((func_23((((uint16_t)func_31(((func_35((l_44[3][0] |= ((*l_42) = (((g_20 || (*l_13)) | g_3) < l_41))), &l_5, l_45, &g_3, g_46) == 0x5DL) , g_53.f0), g_106, g_107) * (uint16_t)l_108[3]) || g_100[0]), l_13, g_109, (*g_109), l_111) ^ 0UL) , (*g_109));
    return g_43;
}


/* ------------------------------------------ */
/* 
 * reads : g_110 g_133 g_3 g_100
 * writes: g_110 g_133 g_3
 */
static int32_t  func_23(uint32_t  p_24, int32_t * p_25, int32_t * p_26, int32_t  p_27, uint32_t  p_28)
{ /* block id: 48 */
    uint16_t l_112 = 0UL;
    int32_t l_119 = (-6L);
    int32_t l_121 = 0x9B834A4FL;
    int32_t l_122 = 0xB6310099L;
    int32_t l_123 = 0x76B60554L;
    int32_t l_124 = 0L;
    int32_t l_126 = 0xE0AF8641L;
    int32_t l_129 = 0L;
    int32_t l_130 = 0x90EDD544L;
    int32_t l_132[4][8];
    uint16_t l_142 = 8UL;
    int i, j;
    for (i = 0; i < 4; i++)
    {
        for (j = 0; j < 8; j++)
            l_132[i][j] = 0x6A696934L;
    }
lbl_139:
    if ((((*p_26) = (&p_27 == (void*)0)) , 0x6D799D52L))
    { /* block id: 50 */
        (*p_26) |= (5L > l_112);
        if (g_110)
            goto lbl_139;
    }
    else
    { /* block id: 52 */
        int32_t *l_113 = &g_110;
        int32_t *l_114 = (void*)0;
        int32_t *l_115 = &g_110;
        int32_t *l_116 = (void*)0;
        int32_t *l_117 = &g_110;
        int32_t *l_118 = (void*)0;
        int32_t *l_120[6] = {&g_110,&g_110,&g_110,&g_110,&g_110,&g_110};
        int i;
        ++g_133;
        for (p_24 = (-25); (p_24 >= 11); ++p_24)
        { /* block id: 56 */
            int32_t **l_138[1];
            int i;
            for (i = 0; i < 1; i++)
                l_138[i] = &l_116;
            p_25 = &p_27;
            return l_121;
        }
    }
    if (((*p_25) |= 0xD2D4BDACL))
    { /* block id: 63 */
        int32_t *l_140 = &g_3;
        int32_t *l_141[8] = {&l_123,&l_123,&l_123,&l_123,&l_123,&l_123,&l_123,&l_123};
        int i;
        --l_142;
    }
    else
    { /* block id: 65 */
        uint32_t l_148 = 0x5C3E68F2L;
        if ((((uint16_t)1UL * (uint16_t)g_100[3]) == p_24))
        { /* block id: 66 */
            int32_t l_147 = 0L;
            (*p_26) = l_147;
            l_119 &= (*p_25);
        }
        else
        { /* block id: 69 */
            (*p_26) |= (*p_25);
        }
        ++l_148;
    }
    return (*p_25);
}


/* ------------------------------------------ */
/* 
 * reads : g_48 g_100
 * writes: g_49
 */
static uint16_t  func_31(struct S0  p_32, uint16_t  p_33, struct S0  p_34)
{ /* block id: 45 */
    (*g_48) = (void*)0;
    return g_100[2];
}


/* ------------------------------------------ */
/* 
 * reads : g_46.f0 g_48 g_51 g_54 g_49 g_50 g_83 g_55 g_100 g_3 g_53
 * writes: g_46.f0 g_48 g_55 g_69 g_83 g_49 g_100 g_3
 */
static uint8_t  func_35(int32_t  p_36, int32_t * p_37, int32_t * p_38, int32_t * p_39, struct S0  p_40)
{ /* block id: 4 */
    uint32_t l_47[8] = {18446744073709551609UL,18446744073709551609UL,0xDE5C4896L,18446744073709551609UL,18446744073709551609UL,0xDE5C4896L,18446744073709551609UL,18446744073709551609UL};
    struct S1 *l_52 = &g_53;
    int32_t l_75 = 0x8CF11409L;
    int32_t l_79 = (-1L);
    int32_t l_82 = (-1L);
    int32_t l_97[7][8] = {{0x1BC6E4F4L,0xA410957FL,0xA410957FL,0x1BC6E4F4L,0x70163A67L,0x1BC6E4F4L,0xA410957FL,0xA410957FL},{0xA410957FL,0x70163A67L,0x4216A80DL,0x4216A80DL,0x70163A67L,0xA410957FL,0x70163A67L,0x4216A80DL},{0x1BC6E4F4L,0x70163A67L,0x1BC6E4F4L,0xA410957FL,0xA410957FL,0x1BC6E4F4L,0x70163A67L,0x1BC6E4F4L},{(-1L),0xA410957FL,0x4216A80DL,0xA410957FL,(-1L),(-1L),0xA410957FL,0x4216A80DL},{(-1L),(-1L),0xA410957FL,0x4216A80DL,0xA410957FL,(-1L),(-1L),0xA410957FL},{0x1BC6E4F4L,0xA410957FL,0xA410957FL,0x1BC6E4F4L,0x70163A67L,0x1BC6E4F4L,0xA410957FL,0xA410957FL},{0xA410957FL,0x70163A67L,0x4216A80DL,0x4216A80DL,0x70163A67L,0xA410957FL,0x70163A67L,0x4216A80DL}};
    int i, j;
    for (g_46.f0 = 0; (g_46.f0 <= 7); g_46.f0 += 1)
    { /* block id: 7 */
        int32_t *l_58[2];
        int i;
        for (i = 0; i < 2; i++)
            l_58[i] = &g_3;
        (*g_51) = g_48;
        (*p_38) &= 0xA787D30FL;
        for (p_36 = 7; (p_36 >= 1); p_36 -= 1)
        { /* block id: 12 */
            int32_t l_59 = 0x3095C3C6L;
            int i;
            (*g_54) = l_52;
            l_59 |= (((uint8_t)(l_58[1] != (**g_51)) << (uint8_t)3) , l_47[p_36]);
        }
    }
    if (((*p_37) = (((int8_t)((&p_36 == (void*)0) >= p_36) % (int8_t)p_36) & 0x2DD2C990L)))
    { /* block id: 18 */
        uint32_t l_66 = 0UL;
        uint8_t *l_67 = (void*)0;
        uint8_t *l_68 = &g_69[5][4];
        struct S1 **l_71[5];
        struct S1 ***l_70 = &l_71[4];
        int32_t l_80 = 0xEEA3ADEBL;
        int32_t l_81[3][4] = {{0xF905AFB0L,0xF905AFB0L,0xF905AFB0L,0xF905AFB0L},{0xF905AFB0L,0xF905AFB0L,0xF905AFB0L,0xF905AFB0L},{0xF905AFB0L,0xF905AFB0L,0xF905AFB0L,0xF905AFB0L}};
        int i, j;
        for (i = 0; i < 5; i++)
            l_71[i] = &g_55;
        (*g_54) = (l_52 = (p_40 , (void*)0));
        if (((uint8_t)(((*l_70) = (((((*l_68) = ((int8_t)l_66 - (int8_t)254UL)) >= 1L) >= (**g_48)) , &g_55)) == (void*)0) >> (uint8_t)3))
        { /* block id: 23 */
            int32_t *l_72 = &g_3;
            int32_t *l_73 = &g_3;
            int32_t *l_74 = &g_3;
            int32_t *l_76 = (void*)0;
            int32_t *l_77 = &g_3;
            int32_t *l_78[3][1];
            int i, j;
            for (i = 0; i < 3; i++)
            {
                for (j = 0; j < 1; j++)
                    l_78[i][j] = &l_75;
            }
            g_83--;
        }
        else
        { /* block id: 25 */
            return l_80;
        }
    }
    else
    { /* block id: 28 */
        int8_t l_92 = 0x1CL;
        int32_t l_94 = 0x5962D988L;
        int32_t l_95 = 0x5F2429B4L;
        int32_t l_96 = (-1L);
        int32_t l_98 = 0xFB5D9459L;
        int32_t l_99[1];
        int i;
        for (i = 0; i < 1; i++)
            l_99[i] = 0xCB2E3AA9L;
        if ((l_75 |= ((*p_38) &= (((*g_54) != l_52) < 0L))))
        { /* block id: 31 */
            return p_36;
        }
        else
        { /* block id: 33 */
            int32_t *l_86 = &l_75;
            int32_t *l_87 = &g_3;
            int32_t *l_88 = &l_79;
            int32_t *l_89 = &l_82;
            int32_t *l_90 = &l_79;
            int32_t *l_91 = &l_82;
            int32_t *l_93[8][4] = {{&l_82,&l_75,&l_75,&l_75},{&g_3,&g_3,&l_82,&l_75},{&l_75,&l_75,&l_75,&l_82},{&l_75,&l_82,&l_82,&l_75},{&g_3,&l_82,&l_75,&l_82},{&l_82,&l_75,&l_75,&l_75},{&g_3,&g_3,&l_82,&l_75},{&l_75,&l_75,&l_75,&l_82}};
            int i, j;
            (*g_48) = (*g_48);
            ++g_100[0];
        }
        for (g_46.f0 = 0; (g_46.f0 < 16); g_46.f0 += 6)
        { /* block id: 39 */
            uint8_t l_105 = 0UL;
            (*p_39) &= (l_96 && g_100[0]);
            (*p_37) = ((*l_52) , l_105);
        }
    }
    return p_40.f0;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i, j;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_20, "g_20", print_hash_value);
    transparent_crc(g_43, "g_43", print_hash_value);
    transparent_crc(g_46.f0, "g_46.f0", print_hash_value);
    transparent_crc(g_50, "g_50", print_hash_value);
    transparent_crc(g_53.f0.f0, "g_53.f0.f0", print_hash_value);
    for (i = 0; i < 7; i++)
    {
        for (j = 0; j < 6; j++)
        {
            transparent_crc(g_69[i][j], "g_69[i][j]", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    transparent_crc(g_83, "g_83", print_hash_value);
    for (i = 0; i < 4; i++)
    {
        transparent_crc(g_100[i], "g_100[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_106, "g_106", print_hash_value);
    transparent_crc(g_107.f0, "g_107.f0", print_hash_value);
    transparent_crc(g_110, "g_110", print_hash_value);
    transparent_crc(g_125, "g_125", print_hash_value);
    transparent_crc(g_127, "g_127", print_hash_value);
    transparent_crc(g_128, "g_128", print_hash_value);
    transparent_crc(g_131, "g_131", print_hash_value);
    transparent_crc(g_133, "g_133", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 47
   depth: 1, occurrence: 2
XXX total union variables: 0

XXX max expression depth: 25
breakdown:
   depth: 1, occurrence: 44
   depth: 2, occurrence: 8
   depth: 3, occurrence: 2
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 9, occurrence: 1
   depth: 25, occurrence: 1

XXX total number of pointers: 58

XXX times a variable address is taken: 61
XXX times a pointer is dereferenced on RHS: 11
breakdown:
   depth: 1, occurrence: 9
   depth: 2, occurrence: 2
XXX times a pointer is dereferenced on LHS: 19
breakdown:
   depth: 1, occurrence: 19
XXX times a pointer is compared with null: 2
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 0
XXX times a pointer is qualified to be dereferenced: 499

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 44
   level: 2, occurrence: 4
   level: 3, occurrence: 1
XXX number of pointers point to pointers: 6
XXX number of pointers point to scalars: 50
XXX number of pointers point to structs: 2
XXX percent of pointers has null in alias set: 20.7
XXX average alias set size: 1.17

XXX times a non-volatile is read: 52
XXX times a non-volatile is write: 45
XXX times a volatile is read: 12
XXX    times read thru a pointer: 4
XXX times a volatile is write: 9
XXX    times written thru a pointer: 2
XXX times a volatile is available for access: 367
XXX percentage of non-volatile access: 82.2

XXX forward jumps: 1
XXX backward jumps: 0

XXX stmts: 39
XXX max block depth: 2
breakdown:
   depth: 0, occurrence: 11
   depth: 1, occurrence: 14
   depth: 2, occurrence: 14

XXX percentage a fresh-made variable is used: 32.5
XXX percentage an existing variable is used: 67.5
********************* end of statistics **********************/

